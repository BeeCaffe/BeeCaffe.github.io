<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>BeeCaffe&#39;s Personal Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="BeeCaffe&#39;s Personal Blogs">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="BeeCaffe&#39;s Personal Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="BeeCaffe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="BeeCaffe&#39;s Personal Blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BeeCaffe&#39;s Personal Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Fiber-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Fiber-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:29:20.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Fiber-In-Linux/">Fiber In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
<p>Coroutines are very similar to threads. However, coroutines are cooperatively multitasked, whereas threads are typically preemptively multitasked. This means that coroutines provide concurrency but not parallelism. The advantages of coroutines over threads are that they may be used in a hard-realtime context (switching between coroutines need not involve any system calls or any blocking calls whatsoever), there is no need for synchronisation primitives such as mutexes, semaphores, etc. in order to guard critical sections, and there is no need for support from the operating system.</p>
<p>It is possible to implement coroutines using preemptively-scheduled threads, in a way that will be transparent to the calling code, but some of the advantages (particularly the suitability for hard-realtime operation and relative cheapness of switching between them) will be lost [1].</p>
<p>In this blog, we will introduce the Linux library “ucontext.h” and use it to implement a simple coroutines program.</p>
<h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><hr>
<ul>
<li><a href="#ucontext_t">ucontext_t</a></li>
</ul>
<!--[mcontext_t](#mcontext_t)-->
<ul>
<li><p><a href="#getcontext">getcontext</a></p>
</li>
<li><p><a href="#setcontext">setcontext</a></p>
</li>
<li><p><a href="#makecontext">makcontext</a></p>
</li>
<li><p><a href="#swapcontext">swapcontext</a></p>
</li>
<li><a href="#code">code</a></li>
</ul>
<h2 id="ucontext-t"><a href="#ucontext-t" class="headerlink" title="ucontext_t"></a>ucontext_t</h2><hr>
<p>The  mcontext_t  type  is  machine-dependent and opaque.  The<br>ucontext_t type is a structure that has at least the following fields:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></span><br><span class="line">            <span class="comment">//points to the context that will be resumed  when  thecurrent  context  terminates</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span>  </span><br><span class="line">           <span class="comment">// the set of  signals  blocked  in this context</span></span><br><span class="line">           <span class="keyword">sigset_t</span>          uc_sigmask;</span><br><span class="line">           <span class="comment">//the stack used by this context</span></span><br><span class="line">           <span class="keyword">stack_t</span>           uc_stack;</span><br><span class="line">           <span class="comment">//the  machine-specific  representation of the saved context, that includes  the  calling  thread machine registers.</span></span><br><span class="line">           <span class="keyword">mcontext_t</span>        uc_mcontext;</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="getcontext"><a href="#getcontext" class="headerlink" title="getcontext"></a>getcontext</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get the user context</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">   -ucp: the <span class="keyword">ucontext_t</span> type, points to the context.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">   seccessed: <span class="number">0</span></span><br><span class="line">   error: <span class="number">-1</span> <span class="keyword">and</span> <span class="built_in">set</span> errno appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set the user context</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">   -ucp: the <span class="keyword">ucontext_t</span> type, points to the context.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">   seccessed: does <span class="keyword">not</span> <span class="keyword">return</span>.</span><br><span class="line">   error: <span class="number">-1</span> <span class="keyword">and</span> <span class="built_in">set</span> errno appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="makecontext"><a href="#makecontext" class="headerlink" title="makecontext"></a>makecontext</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modifies the context pointed to by ucp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, <span class="keyword">void</span> (*func)(), <span class="keyword">int</span> argc, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -ucp: the context pointer.</span><br><span class="line">    -func: When <span class="keyword">this</span> context is later activated the function func is called, </span><br><span class="line">    -argc: passed the  series  of  integer arguments  that  follow  argc to func; the caller must specify the number of these arguments in argc .</span><br><span class="line"><span class="keyword">return</span>: </span><br><span class="line">    no</span><br></pre></td></tr></table></figure>
<h2 id="swapcontext"><a href="#swapcontext" class="headerlink" title="swapcontext"></a>swapcontext</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//saves the current context in the structure pointed to by oucp, and then activates the context pointed to by ucp.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -oucp: The swapcontext() function saves the current context in the structure pointed to by oucp.</span><br><span class="line">    -ucp:  the context pointer.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: does <span class="keyword">not</span> <span class="keyword">return</span>, (But we may <span class="keyword">return</span> later, in <span class="keyword">case</span> oucp is activated, in which <span class="keyword">case</span>  it  looks  like  swapcontext() returns <span class="number">0.</span>)</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> sets errno appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><hr>
<p>In this program, we use getcontext() to get the context before print “hello world”, then we use setcontext() to recover the context which we stored. Therefore, this program print “hello world” recurrently.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using getcontext and setcontext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">ucontext_t</span> context;</span><br><span class="line"></span><br><span class="line">        getcontext(&amp;context);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        setcontext(&amp;context);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>result:<br><img src="https://upload-images.jianshu.io/upload_images/13348038-76df75111b70b830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Coroutine#Comparison_with_threads" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Coroutine#Comparison_with_threads</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Fiber-In-Linux/" data-id="cka8b3cit0007okv674gre1vy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RWLock-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/RWLock-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:28:33.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/RWLock-In-Linux/">RWLock In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Mutex Lock blocks all the threads which attempts to enter critical section. However, the enter cirtical section operation can be divided into read data and write data. According to this principle, the lock can be separted as read lock and write lock. The read-write lock requires to obey the following rules:</p>
<ul>
<li>as long as no thread holds any write lock, any threads can get any type (read or write) lock to read.</li>
<li>when and only when no lock is used to write or read, write lock can be allocated and used to write.</li>
</ul>
<p>That is to say, as long as no thread is modifing critical section, any type lock can be used to read. When and only when on any other threads are modifing critical section, write lock is able to write.</p>
<h1 id="header"><a href="#header" class="headerlink" title="header"></a>header</h1><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p><a href="#pthread_rwlock_t">pthread_rwlock_t</a></p>
<p><a href="#pthread_rwlock_rdlock">pthread_rwlock_rdlock</a></p>
<p><a href="#pthread_rwlock_wrlock">pthread_rwlock_wrlock</a></p>
<p><a href="#pthread_rwlock_unlock">pthread_rwlock_unlock</a></p>
<p><a href="#pthread_rwlock_trywrlock">pthread_rwlock_tryrdlock</a></p>
<p><a href="#pthread_rwlock_trywrlock">pthread_rwlock_trywrlock</a></p>
<p><a href="pthread_rwlock_destroy">pthread_rwlock_destroy</a></p>
<p><a href="#pthread_rwlockattr_init">pthread_rwlockattr_init</a></p>
<p><a href="pthread_rwlockattr_destroy">pthread_rwlockattr_destroy</a></p>
<p><a href="pthread_rwlockattr_getpshared">pthread_rwlockattr_getpshared</a></p>
<p><a href="pthread_rwlockattr_setpshared">pthread_rwlockattr_setpshared</a></p>
<h2 id="pthread-rwlock-t"><a href="#pthread-rwlock-t" class="headerlink" title="pthread_rwlock_t"></a>pthread_rwlock_t</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The defination of pthread_rwlock_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> rw_mutex;   <span class="comment">/*basic lock on this struct*/</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> rw_condreaders;  <span class="comment">/*for reader threads waiting*/</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> rw_condwriters;  <span class="comment">/*for writer threads waiting*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_magic;   <span class="comment">/*for error checking*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_nwaitreaders;    <span class="comment">/*the number waiting*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_nwaitwriters;    <span class="comment">/*the number waiting*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_refcount;    <span class="comment">/*-1 if writer has the lock, else readers holding the lock*/</span></span><br><span class="line">&#125;<span class="keyword">pthread_rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_RWLOCK_INITIALIZER&#123;</span></span><br><span class="line">    PTHREAD_LOCK_INITIALIZER,</span><br><span class="line">    PTHREAD_COND_INITIALIZER,</span><br><span class="line">    PTHREAD_COND_INITIALIZER,</span><br><span class="line">    RW_MAGIC,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get a read lock, if the lock hold by other thread, blocking and waiting for unlocking.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-wrlock"><a href="#pthread-rwlock-wrlock" class="headerlink" title="pthread_rwlock_wrlock"></a>pthread_rwlock_wrlock</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get a write lock, if lock is got by other threads, blocking and waiting for unlocking.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a>pthread_rwlock_unlock</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//release a read-wirte lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-tryrdlock"><a href="#pthread-rwlock-tryrdlock" class="headerlink" title="pthread_rwlock_tryrdlock"></a>pthread_rwlock_tryrdlock</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gets a read lock, if the lock hold by other thread, return a EXXX without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-trywrite"><a href="#pthread-rwlock-trywrite" class="headerlink" title="pthread_rwlock_trywrite"></a>pthread_rwlock_trywrite</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gets a write lock, if the lock hold by other thread, return a EXXX without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes a read-write lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr,<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    -attr: the attribute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//destroy a read-write lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlockattr-init"><a href="#pthread-rwlockattr-init" class="headerlink" title="pthread_rwlockattr_init"></a>pthread_rwlockattr_init</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set a pthread_rwlockattr_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlockattr-destroy"><a href="#pthread-rwlockattr-destroy" class="headerlink" title="pthread_rwlockattr_destroy"></a>pthread_rwlockattr_destroy</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//destroy a pthread_rwlockattr_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlockattr-getpshared"><a href="#pthread-rwlockattr-getpshared" class="headerlink" title="pthread_rwlockattr_getpshared"></a>pthread_rwlockattr_getpshared</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr,<span class="keyword">int</span> *valptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line">    -valptr: the attribute value</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="pthread-rwlockattr-setpshared"><a href="#pthread-rwlockattr-setpshared" class="headerlink" title="pthread_rwlockattr_setpshared"></a>pthread_rwlockattr_setpshared</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr,<span class="keyword">int</span> *valptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line">    -valptr: the attribute value</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/RWLock-In-Linux/" data-id="cka8b3civ000bokv6dartgzi7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mutex-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Mutex-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:27:58.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Mutex-In-Linux/">Mutex In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;thread.h&gt;</span><br></pre></td></tr></table></figure>
<h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><hr>
<p><a href="#pthread_mutex_t">pthread_mutex_t</a></p>
<p><a href="#pthread_mutex_lock">pthread_mutex_lock</a></p>
<p><a href="#pthread_mutex_trylock">pthread_mutex_trylock</a></p>
<p><a href="pthread_mutex_init">pthread_muext_init</a></p>
<p><a href="#pthread_mutex_unlock">pthread_mutex_unlock</a></p>
<p><a href="#pthread_mutex_destroy">pthread_mutex_destroy</a></p>
<h2 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h2><p>The pthread_mutex_t is a mutex data type, which can be initialized by two methods.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if pthread_mutex_t is declared as a static variable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock=PTHREAD_MUTEX_INITILIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if pthread_mutex_t is declared as a dynamic variable</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span>* lock;</span><br><span class="line">pthread_mutex_init(lock);</span><br></pre></td></tr></table></figure></p>
<h2 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h2><p>Try to lock a mutex, if the mutex is locked, blocking and waiting for until it is unlock.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lock a mutex variable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mptr: a pointer of mutex.</span><br><span class="line"><span class="keyword">return</span>: </span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure></p>
<h2 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock"></a>pthread_mutex_trylock</h2><p>Try to lock a mutex, if it is locked, return a EBUSY.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mptr: a pointer of mutex.</span><br><span class="line"><span class="keyword">return</span>: </span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure></p>
<h2 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h2><p>unlock a mutex, if it is unlock, blocking and waitting.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mptr: a pointer of mutex</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure></p>
<h2 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy"></a>pthread_mutex_destroy</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mutex: the mutex type</span><br><span class="line">    -attr: attribute of mutex</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: Exxx</span><br></pre></td></tr></table></figure>
<h2 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mutex: the mutex type</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//consumer and producer model</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> nmax;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> ncur;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> nval;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> Shared::lock=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Shared::<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">int</span> Shared::nmax=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Shared::ncur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Shared::nval=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;Shared::lock);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread ["</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">"] is writing value: "</span>&lt;&lt;Shared::nval&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(Shared::ncur&gt;=Shared::nmax)&#123;</span><br><span class="line">                        pthread_mutex_unlock(&amp;Shared::lock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Shared::<span class="built_in">array</span>.push_back(Shared::nval);</span><br><span class="line">                Shared::ncur++;</span><br><span class="line">                Shared::nval++;</span><br><span class="line">                pthread_mutex_unlock(&amp;Shared::lock);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Shared::<span class="built_in">array</span>.size();++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consume value: "</span>&lt;&lt;Shared::<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"arguments number error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nmax=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> nthreads=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">pthread_t</span>&gt; <span class="title">producer_tids</span><span class="params">(nthreads)</span></span>;</span><br><span class="line">        <span class="keyword">pthread_t</span> consumer_tid;</span><br><span class="line">        Shared::nmax=nmax;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nthreads;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pthread_create(&amp;producer_tids[i],<span class="literal">nullptr</span>,producer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nthreads;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pthread_join(producer_tids[i],<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_join error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread "</span>&lt;&lt;i&lt;&lt;<span class="string">" Done!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;consumer_tid,<span class="literal">nullptr</span>,consumer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pthread_join(consumer_tid,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_join error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main Function Done!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Mutex-In-Linux/" data-id="cka8b3ciw000fokv684wr3rsr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thread-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Thread-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:27:20.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Thread-In-Linux/">Thread In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><hr>
<ul>
<li><a href="#pthread_create">pthread_create</a>()</li>
<li><a href="#pthread_join">pthread_join</a>()</li>
<li><a href="#pthread_detach">pthread_detach</a>()</li>
<li><a href="#pthread_self">pthread_slef</a>()</li>
<li><a href="#pthread_exit">pthread_exit</a>()</li>
</ul>
<h2 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void* (*start_routine)(void*), void *arg);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>brief:</strong> The pthread_create() function starts a new thread in the calling process, the new thread starts execution by invoking start_routine();</li>
<li><p><strong>arguments:</strong></p>
<ul>
<li><strong>-thread:</strong> The pointer points to thread identifier.</li>
<li><strong>-attr:</strong> The  attr argument points to a pthread_attr_t structure whose contents are used at thread creation time to determine attributes for the new thread;this structure is initialized using pthread_attr_init(3) and related functions.  If  attr  is  NULL,  then  the  thread  is  created  with  default attributes.</li>
<li><strong>-start_routine:</strong> The function address of thread run.</li>
<li><strong>-arg</strong> The arguments of start_toutine.</li>
</ul>
</li>
<li><p><strong>return value:</strong><br>On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined.</p>
</li>
<li><strong>Code:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread&gt;</span></span></span><br><span class="line"><span class="comment">//this is a sample example of pthread_create.</span></span><br><span class="line"><span class="comment">//start routine 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_1: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//start routine2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func2</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_2: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp1;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp2;</span><br><span class="line">    <span class="comment">//using pthread_create creates a function</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tidp1,<span class="literal">nullptr</span>,func1,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//using pthread_create creates a function</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tidp2,<span class="literal">nullptr</span>,func2,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_main: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>Note:</strong> The library “pthread.h” is not a build in library of linux, when you compile source code, you should add commain <strong>-lpthread</strong> like this:<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ thread_create.cc -lpthread</span><br></pre></td></tr></table></figure>
<h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h2></li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span>** retval)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>brief:</strong> The pthread_join() function waits for the thread specified by thread to terminate, If that thread has already terminated, then pthread_join run immediately.The thread specified by thread must be joinable.</p>
</li>
<li><p><strong>arguments:</strong> </p>
<ul>
<li><strong>-thread:</strong> The thread identifier that is waitted.</li>
<li><strong>-retval:</strong>  The return value of thread which is waitted</li>
</ul>
</li>
<li><p><strong>return value</strong> On success, pthread_join() returns 0; on error, it returns an error number.</p>
</li>
<li><p><strong>Note:</strong> This function is a blocking funtion. Suppose we have two thread, thread A and thread B. If we call pthread_join() int thread A, thread A will blocking wait for the finish of thread B. If we do not call pthread_join, thread A may finish quickly, and thread B can not be executed.</p>
</li>
<li><p><strong>Code:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//In this program, we do not call pthread_join(), the main </span></span><br><span class="line"><span class="comment">//function finished before thread_1 fininshed.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_1: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,func1,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_main: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main Function END!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result:<br><img src="https://upload-images.jianshu.io/upload_images/13348038-c5c6cfe7efe3895a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//The pthread_join() is called, the main thread waits for //thread 1 finish.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_1: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,func1,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_main: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pthread_join(tid,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main Function END!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13348038-4fd12eaa3611cca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h2><hr>
<p><a href="https://note.youdao.com/" target="_blank" rel="noopener">link</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_detach(pthread_t thread);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>Brief:</strong> The pthread_detach()  function  marks the thread identified by thread as detached.  When a detached thread terminates, its resources are automati‐cally released back to the system without the need for another thread to join with the terminated thread.Attempting to detach an already detached thread results in unspecified behavior.</li>
<li><strong>Arguments:</strong><ul>
<li><strong>-thread:</strong> The detached thread identifier.</li>
</ul>
</li>
<li><p><strong>Return Value:</strong><br>On success, pthread_detach() returns 0; on error, it returns an error number.</p>
</li>
<li><p><strong>Code:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">&#x2F;&#x2F;The func is a dead loop, but the resources of pthread_detach() </span><br><span class="line">&#x2F;&#x2F;marks program are automatically released back to system. So </span><br><span class="line">&#x2F;&#x2F;the loop finished after Main process is finished.</span><br><span class="line">void* func(void* arg)&#123;</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">                std::cout&lt;&lt;&quot;thread_1 running ...&quot;&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pthread_t tid;</span><br><span class="line">        if(pthread_create(&amp;tid,nullptr,func,nullptr)&#x3D;&#x3D;-1)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_detach(tid);</span><br><span class="line">        std::cout&lt;&lt;&quot;Main Function Done!&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13348038-92c4f0747486ddab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_t pthread_self(void);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Brief:</strong> The pthread_self() function returns the ID of the calling thread.  This is the same value that is returned in *thread in the pthread_create(3) call that created this thread.</li>
<li><strong>Return:</strong><br>This function always succeeds, returning the calling thread’s ID.</li>
<li><strong>Code:</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* func(void* arg)&#123;</span><br><span class="line">        pthread_detach(pthread_self());</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">                std::cout&lt;&lt;&quot;thread 1 running ...\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pthread_t tid;</span><br><span class="line">        if(pthread_create(&amp;tid,nullptr,func,nullptr))&#123;</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;&quot;Main Function Done!&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void pthread_exit(void* retval);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Brief:</strong></p>
<p>  The  pthread_exit()  function terminates the calling thread and returns a value via retval that (if the thread is joinable) is available to another<br>  thread in the same process that calls pthread_join(3).</p>
<p>  Any clean-up handlers established by pthread_cleanup_push(3) that have not yet been popped, are popped (in the reverse of the order in  which  they<br>  were  pushed)  and  executed.   If the thread has any thread-specific data, then, after the clean-up handlers have been executed, the corresponding<br>  destructor functions are called, in an unspecified order.</p>
<p>  When a thread terminates, process-shared resources (e.g., mutexes, condition variables, semaphores, and file descriptors)  are  not  released,  and<br>  functions registered using atexit(3) are not called.</p>
<p>  After  the  last  thread  in  a  process terminates, the process terminates as by calling exit(3) with an exit status of zero; thus, process-shared<br>  resources are released and functions registered using atexit(3) are called.</p>
</li>
<li><strong>Arguments:</strong><ul>
<li><strong>-retval:</strong> void* pointer, I do not know the mean of this argument.</li>
</ul>
</li>
<li><strong>Code:</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* func(void* arg)&#123;</span><br><span class="line">        pthread_detach(pthread_self());</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">                std::cout&lt;&lt;&quot;thread 1 running ...\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pthread_t tid;</span><br><span class="line">        if(pthread_create(&amp;tid,nullptr,func,nullptr))&#123;</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;&quot;Main Function Done!&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Thread-In-Linux/" data-id="cka8b3cj1000qokv60g7gbug7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Pipe-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Pipe-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:26:33.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Pipe-In-Linux/">Pipe In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;uinstd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><ul>
<li><a href="#conception">conception</a></li>
<li><a href="#pipe">pipe</a></li>
<li><a href="#pipe2">pipe2</a></li>
<li><a href="#code">code</a></li>
</ul>
<h2 id="conception"><a href="#conception" class="headerlink" title="conception"></a>conception</h2><hr>
<p>Pipe is one of the most basic IPC machanism in Linux system, whihc is able to tranfer data in parent and child process. We can easily creat and use pipe by Linux system call. The size of pipe is <strong>65KB</strong> in generally.</p>
<p><strong>The attributes of pipe includes:</strong></p>
<ol>
<li>The pipe is a file in logical. Actually, it is a Linux kernel buffer.</li>
<li>There are two file descriptor in a pipe, and they respectively represents write and read.</li>
<li>The data must enter pipe by write end, and leave pip by read end.<br>In a word, pipe is a circle queue mechanism which is used by linux kernel.</li>
</ol>
<p><strong>The limitaion of pipe:</strong></p>
<ol>
<li>Once the data is readed, the data are taken forever, and the pipe dosen’t reserve those data.</li>
<li>The pipe is a half word channel, which can only be read in one side.</li>
<li>The pipe can only be accessed by the processes which has the same father process or with father process.</li>
</ol>
<p><strong>The process of parent thread and child thread IPC</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13348038-361488176f58b439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>The father process calls pipe function to cerate an pipe, which obtains fd[0] and fd[1].</li>
<li>The father process fork() an child process, both father and child process have fd[0] and fd[0].</li>
<li>The father process colses the read end and child process colse the write end. Then, the father process sends message to the pipe and the child process gets the data from pipe.</li>
</ol>
<p><strong>Four special situations about pipes</strong><br><img src="https://upload-images.jianshu.io/upload_images/13348038-9789f7955152bb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>If write side has no writers (write side file descriptor = 0), after data read over, the read file descriptor will return zero.</li>
<li><p>If write side has writers (write size file descriptor  &gt; 0), after pipe is empty, the reader will wait for the writer to write.<br><img src="https://upload-images.jianshu.io/upload_images/13348038-d58d65ba47340439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>If read side has no readers (read side file descriptor = 0), when writer try to write datas to the pipe, the process will receive SIGPIPE.</p>
</li>
<li>If read side has readers (read side file descriptor &gt; 0), when pipe is full, the writer will block and wait.</li>
</ol>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;create a pipe</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line"></span><br><span class="line">args</span><br><span class="line">    - pipefd: two file descriptor</span><br><span class="line">return</span><br><span class="line">    - success: 0</span><br><span class="line">    - error: -1</span><br><span class="line">    </span><br><span class="line">Notes:</span><br><span class="line">    - pipefd[0]: read</span><br><span class="line">    - pipefd[1]: write</span><br></pre></td></tr></table></figure>
<h2 id="pipe2"><a href="#pipe2" class="headerlink" title="pipe2"></a>pipe2</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If flags is 0, then pipe2() is the same as pipe().</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe2</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">args:</span><br><span class="line">    - pipefd: The file descriptor of pipe.</span><br><span class="line">    - flags:</span><br><span class="line">        - O_CLOEXEC:</span><br><span class="line">        - O_DIRECT</span><br><span class="line">        - O_NONBLOCK</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    - successed: <span class="number">0</span></span><br><span class="line">    - error: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>An example of pipe, we fork a child process in the main process, the main process write data to the pipe and the child process read the data and print it to the console.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(fd)==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span>* p=<span class="string">"test of pipe\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">//child process</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>((len=read(fd[<span class="number">0</span>],buff,<span class="keyword">sizeof</span>(buff)))==<span class="number">-1</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(write(STDOUT_FILENO,buff,len)==<span class="number">-1</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//main process</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(write(fd[<span class="number">1</span>],p,<span class="built_in">strlen</span>(p))==<span class="number">-1</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">         <span class="keyword">char</span>* s=<span class="string">"main end!\n"</span>;</span><br><span class="line">         write(STDOUT_FILENO,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Pipe-In-Linux/" data-id="cka8b3ciu0009okv6eatubqob" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Semaphore-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Semaphore-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:25:51.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Semaphore-In-Linux/">Semaphore In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><hr>
<p><a href="#sem_t">sem_t</a></p>
<p><a href="#sem_init">sem_init</a></p>
<p><a href="#sem_open">sem_open</a></p>
<p><a href="#sem_destroy">sem_destroy</a></p>
<p><a href="#sem_wait">sem_wait</a></p>
<p><a href="#sem_post">sem_post</a></p>
<p><a href="#code">code</a></p>
<h2 id="sem-t"><a href="#sem-t" class="headerlink" title="sem_t"></a>sem_t</h2><hr>
<p>In C language, the sem_t is the semphore structor, which is a long int in basic.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef long long sem_t;</span><br></pre></td></tr></table></figure></p>
<h2 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>brief:</strong>  initializes the unnamed semaphore at the address pointed to by sem.  The value argument specifies the initial value for the semaphore.</li>
<li><p><strong>arguments:</strong></p>
<ul>
<li><strong>-sem:</strong> The semaphore flag.</li>
<li><p><strong>-pshared:</strong> indicates whether this semaphore is to be shared between the threads of a process, or between processes.<br>If pshared has the value 0, then the semaphore is shared between the threads of a process, and should be located at some address that is visible to<br> all threads (e.g., a global variable, or a variable allocated dynamically on the heap).</p>
<p> If pshared is nonzero, then the semaphore is shared between processes, and should be located  in  a  region  of  shared  memory  (see  shm_open(3),<br> mmap(2),  and shmget(2)).  (Since a child created by fork(2) inherits its parent’s memory mappings, it can also access the semaphore.)  Any process<br> that can access the shared memory region can operate on the semaphore using sem_post(3), sem_wait(3), and so on.</p>
<p> Initializing a semaphore that has already been initialized results in undefined behavior.</p>
</li>
<li><strong>-value:</strong> </li>
</ul>
</li>
<li><strong>return value:</strong><br>sem_init() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.</li>
<li><strong>code:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes unamed semaphore</span></span><br><span class="line"><span class="keyword">sem_t</span> *mutex;</span><br><span class="line">sem_init(mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="sem-open"><a href="#sem-open" class="headerlink" title="sem_open"></a>sem_open</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sem_t *sem_open(const char *name, int oflag);</span><br><span class="line">sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>brief:</strong>  initialize and open a named semaphore</li>
<li><p><strong>arguments:</strong> </p>
<ul>
<li><strong>-name:</strong> name of semphore.</li>
<li><p><strong>-flag:</strong> specifies flags that control the operation of the call. (Definitions  of  the  flags  values  can  be  obtained  by  including<br> &lt;fcntl.h&gt;.)  If O_CREAT is specified in oflag, then the semaphore is created if it does not already exist.  The owner (user ID) of the semaphore is<br> set to the effective user ID of the calling process.  The group ownership (group ID) is set to the effective group ID of the calling  process.   If<br> both O_CREAT and O_EXCL are specified in oflag, then an error is returned if a semaphore with the given name already exists.</p>
<p> If  O_CREAT is specified in oflag, then two additional arguments must be supplied.  The mode argument specifies the permissions to be placed on the<br> new semaphore, as for open(2).  (Symbolic definitions for the permissions bits can be obtained by including &lt;sys/stat.h&gt;.)   The  permissions  set‐<br> tings are masked against the process umask.  Both read and write permission should be granted to each class of user that will access the semaphore.<br> The value argument specifies the initial value for the new semaphore.  If O_CREAT is specified, and a semaphore with the given name already exists,<br> then mode and value are ignored.</p>
</li>
</ul>
</li>
<li><strong>return value:</strong>  On  success,  sem_open()  returns the address of the new semaphore; this address is used when calling other semaphore-related functions.  On error,<pre><code>sem_open() returns SEM_FAILED, with errno set to indicate the error.
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes a named semaphore</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br><span class="line">mutex=sem_open(<span class="string">"name_mutex"</span>,O_CREATE,<span class="number">0644</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="sem-desroy"><a href="#sem-desroy" class="headerlink" title="sem_desroy"></a>sem_desroy</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> int sem_destroy(sem_t *sem);</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>brief:</strong> destroy an unnamed semaphore, sem_destroy() destroys the unnamed semaphore at the address pointed to by sem. Only a semaphore that has been initialized by sem_init(3) should be destroyed using sem_destroy().Destroying a semaphore that other processes or threads are currently blocked on (in sem_wait(3)) produces undefined behavior.Using a semaphore that has been destroyed produces undefined results, until the semaphore has been reinitialized using sem_init(3).</li>
<li><strong>arguments:</strong> <ul>
<li><strong>-sem:</strong> the semaphore ID.</li>
</ul>
</li>
<li><strong>return value:</strong> sem_destroy() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.</li>
<li><strong>code</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;initializes a semaphore and destory it.</span><br><span class="line">sem_t* mutex;</span><br><span class="line">sem_init(mutex,0,1);</span><br><span class="line">sem_desotroy(mutex);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="sem-wait-sem-trywait-sem-timewait"><a href="#sem-wait-sem-trywait-sem-timewait" class="headerlink" title="sem_wait, sem_trywait, sem_timewait"></a>sem_wait, sem_trywait, sem_timewait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;blocking lock a semaphore</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">args: </span><br><span class="line">    -sem: the semaphore ID.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;unblocking lock a semaphore</span><br><span class="line">int sem_trywait(sem_t *sem);</span><br><span class="line">args:</span><br><span class="line">    -sem: the semaphore ID</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="line">args:</span><br><span class="line">    -sem: the semaphore ID</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>brief:</strong> </p>
<ul>
<li><p><strong>sem_wait()</strong> decrements (locks) the semaphore pointed to by sem.  If the semaphore’s value is greater than zero, then the decrement proceeds, and thefunction returns, immediately.  If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.</p>
</li>
<li><p><strong>sem_trywait()</strong>  is  the  same  as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking.</p>
</li>
<li><p><strong>sem_timedwait()</strong> is the same as sem_wait(), except that abs_timeout specifies a limit on the amount of time that the call should block if the decre‐ment cannot be immediately performed.  If the operation can be performed immediately, then sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout.  Fur‐thermore, the validity of abs_timeout is not checked in this case.</p>
</li>
</ul>
</li>
<li><p><strong>return value:</strong>   All of these functions return 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is  set  to  indicate the error.</p>
</li>
<li><strong>code:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//place holder</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;increments (unlock) a semaphore</span><br><span class="line">int sem_post(sem_t *sem);</span><br><span class="line">args:</span><br><span class="line">    -sem: the semaphore ID</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>brief:</strong>  sem_post()  increments  (unlocks)  the  semaphore pointed to by sem.  If the semaphore’s value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore.</p>
</li>
<li><p><strong>return value:</strong>  sem_post() returns 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.</p>
</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>There is my own simple semaphore class , which based on semaphore in linux. There are three files in total: semaphore.h, semaphore.cc and semaphore_test<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BEE_MUTEX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BEE_MUTEX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"macro.h"</span></span></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> *Class Semaphore</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Semaphore(<span class="keyword">int</span> count=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ~Semaphore();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trywait</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//The semaphore</span></span><br><span class="line">    <span class="keyword">sem_t</span> m_semaphore;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mutex.h"</span></span></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> *Class Semaphore</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line">Semaphore::Semaphore(<span class="keyword">int</span> count)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;m_semaphore,<span class="number">0</span>,count)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_init error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::~Semaphore()&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_destroy(&amp;m_semaphore)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_destroy error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::wait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;m_semaphore)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_wait error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::trywait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_trywait(&amp;m_semaphore)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_trywait error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_post(&amp;m_semaphore))&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_post error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>And There is a test program of my Semaphore class, where we use semaphore to make  main thread thread 1 run a function func(). We set a global semaphore instance sem, and initializes it’s semaphore as 1. When main function or thread 1 are going to run, they must get a semaphore. Therefore, the program would be alternately executed in turn.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"../net/mutex.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bee;</span><br><span class="line"><span class="function"><span class="keyword">static</span> bee::Semaphore <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem.wait();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"func is running ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        sem.notify();</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,func,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem.wait();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"main is running ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        sem.notify();</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(tid,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>result:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Semaphore-In-Linux/" data-id="cka8b3ciy000jokv6h0wg3s07" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Basic-IO-In-Linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Basic-IO-In-Linux/" class="article-date">
  <time datetime="2020-05-15T14:24:34.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Basic-IO-In-Linux/">Basic IO In Linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="File-IO"><a href="#File-IO" class="headerlink" title="File IO"></a>File IO</h1><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcnt.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><hr>
<p><a href="#open">open</a></p>
<p><a href="#creat">creat</a></p>
<p><a href="#close">close</a></p>
<p><a href="#lseek">lseek</a></p>
<p><a href="#read">read</a></p>
<p><a href="#write">write</a></p>
<p><a href="#code">code</a></p>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Opens a file and return it's file descriptor</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">int</span> oflag,...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">args:</span></span><br><span class="line">    - pathname: file path name</span><br><span class="line">    - oflag:</span><br><span class="line">        - O_RDONLY: read only</span><br><span class="line">        - O_WRONLY: write only</span><br><span class="line">        - RDWR: write <span class="keyword">and</span> read</span><br><span class="line">        - O_APPEND: appends to file end</span><br><span class="line">        - O_CREAT: <span class="keyword">if</span> file <span class="keyword">not</span> exist, creates a <span class="keyword">new</span> one</span><br><span class="line">        - O_EXCL: Test wether a file exist <span class="keyword">or</span> <span class="keyword">not</span>, <span class="keyword">if</span> <span class="keyword">not</span> atomaicly creates a file</span><br><span class="line">        - O_TRUNC: I dont know</span><br><span class="line">        - O_NOCTTY: I dont know</span><br><span class="line">        - O_NONBLOCK: If ptahname is a FIFO <span class="keyword">or</span> a block, <span class="built_in">set</span> the file to a nonblocking status.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The file descriptor</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately</span><br></pre></td></tr></table></figure>
<h2 id="creat"><a href="#creat" class="headerlink" title="creat"></a>creat</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//creats a file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - pathname: The file pathname</span><br><span class="line">    - mode:</span><br><span class="line">        - O_RDONLY: read only</span><br><span class="line">        - O_WRONLY: write only</span><br><span class="line">        - RDWR: write <span class="keyword">and</span> read</span><br><span class="line">        - O_APPEND: appends to file end</span><br><span class="line">        - O_CREATE: <span class="keyword">if</span> file <span class="keyword">not</span> exist, creates a <span class="keyword">new</span> one</span><br><span class="line">        - O_EXCL: Test wether a file exist <span class="keyword">or</span> <span class="keyword">not</span>, <span class="keyword">if</span> <span class="keyword">not</span> atomaicly creates a file</span><br><span class="line">        - O_TRUNC: I dont know</span><br><span class="line">        - O_NOCTTY: I dont know</span><br><span class="line">        - O_NONBLOCK: If ptahname is a FIFO <span class="keyword">or</span> a block, <span class="built_in">set</span> the file to a nonblocking status.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The file descriptor</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//close a file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fildes)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    - successed: <span class="number">0</span></span><br><span class="line">    - error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fildes,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor.</span><br><span class="line">    - offset: The offset.</span><br><span class="line">    - whence:</span><br><span class="line">        -SEEK_SET: The distance between file begin <span class="keyword">and</span> offset.</span><br><span class="line">        -SEEK_END: Set the offset to file end add offset.</span><br><span class="line">        -SEEK_CUR: Set the offset to current value add offset.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The <span class="keyword">new</span> location of file.</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">void</span>* buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor</span><br><span class="line">    - buff: The buffer to store data</span><br><span class="line">    - nbytes: Read how many bytes.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed:</span><br><span class="line">        - meets EOF: <span class="number">0</span></span><br><span class="line">        - The bytes of read.</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fildes,<span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor</span><br><span class="line">    - buff: The write buffer</span><br><span class="line">    - nbytes: How many bytes to write</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The bytes of write</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets appropriately</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package your own io functions</span></span><br><span class="line"><span class="comment">//io.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BEE_IO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BEE_IO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"utils.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"macro.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: opens a file, if not exist creats it.</span></span><br><span class="line"><span class="comment"> *@param[in] pathname: the file pathname</span></span><br><span class="line"><span class="comment"> *@param[in] ofalgs: The file open mode, default by creat and write and read.</span></span><br><span class="line"><span class="comment"> *@reurn: The file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname,<span class="keyword">int</span> oflags=<span class="number">0</span>,<span class="keyword">mode_t</span> mode=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: creats a file.</span></span><br><span class="line"><span class="comment"> *@param[in] pathname: the file pathname</span></span><br><span class="line"><span class="comment"> *@param[in] ofalgs: The file open mode, default by creat and write and read.</span></span><br><span class="line"><span class="comment"> *@return: The file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Creat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname, <span class="keyword">mode_t</span> mode=O_CREAT|O_RDWR)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: close a file.</span></span><br><span class="line"><span class="comment"> *@param[in] fd: the file descriptor</span></span><br><span class="line"><span class="comment"> *@return: NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence=SEEK_SET)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: read a file.</span></span><br><span class="line"><span class="comment"> *@param[in] fd: the file descriptor</span></span><br><span class="line"><span class="comment"> *@return: The file contains string..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: write a file.</span></span><br><span class="line"><span class="comment"> *@param[in] fd: the file descriptor</span></span><br><span class="line"><span class="comment"> *@param[in] buffer: The string to write</span></span><br><span class="line"><span class="comment"> *@return: NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packages your own io functions</span></span><br><span class="line"><span class="comment">//io.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"io.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 8192</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname,<span class="keyword">int</span> oflags,<span class="keyword">mode_t</span> mode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(access(pathname.c_str(),F_OK)!=<span class="number">0</span>)&#123;</span><br><span class="line">        fd=open(pathname.c_str(),O_CREAT|O_RDWR|O_TRUNC,<span class="number">0777</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"creats a new file in: "</span>&lt;&lt;pathname&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oflags==<span class="number">0</span> &amp;&amp; mode==<span class="number">0</span>)&#123;</span><br><span class="line">        fd=open(pathname.c_str(),O_RDWR|O_APPEND);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fd=open(pathname.c_str(),oflags,mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"open file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Creat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname, <span class="keyword">mode_t</span> mode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd=creat(pathname.c_str(),mode);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"creat file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(close(fd)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"close file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line">   lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">   <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        n=read(fd,buf,BUFF_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">            ASSERT_DESC(<span class="literal">false</span>,<span class="string">"read file error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">tmp</span><span class="params">(buf)</span></span>;</span><br><span class="line">        str.append(tmp);</span><br><span class="line">        bzero(buf,BUFF_SIZE);</span><br><span class="line">   &#125;</span><br><span class="line">   lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span></span>&#123;</span><br><span class="line">    <span class="comment">//char buf[]="";</span></span><br><span class="line">    <span class="keyword">int</span> len=buffer.size();</span><br><span class="line">    <span class="comment">//strncpy(buf,buffer.c_str(),len+1);</span></span><br><span class="line">    <span class="keyword">if</span>(write(fd,buffer.c_str(),len)!=len)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"write file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Basic-IO-In-Linux/" data-id="cka8b3cie0000okv6cml82a2f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DFS-Of-Graph" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/DFS-Of-Graph/" class="article-date">
  <time datetime="2020-05-15T14:22:42.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/DFS-Of-Graph/">DFS Of Graph</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Conception"><a href="#Conception" class="headerlink" title="Conception"></a>Conception</h2><p>Depth First Search, called DFS, which is one of graphics traversing or searching methods. The basic idea is exploreing as far as possible along each branch from any start node. DFS algorithm can be implementted recurrently, after a node is visited, it’s visit flag should be setted as true. if the current node has no other un-traveled adjacent nodes, it should return, and find another un-traveled branch.</p>
<p>There are two types of grapics storage structures – adjacent matrix storage and adjacency list storage. In this blog, we take adjacent matrix as the storage structure of graphics.</p>
<p>There is a simple implementation of DFS as follows:</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
////DFS
////using adjacent matrix storage
class Graph{
    private:
        ////vertices 
        vector&lt;string&gt; m_vex;
        ////arcs
        vector&lt;vector&lt;int&gt;&gt; m_arcs;
        ////is visited flag
        vector&lt;bool&gt; m_flags;
        ////vertex number
        int m_vexnum;

    public:

        //// constructor
        Graph(vector&lt;string&gt; vex){
            m_vex=vex;
            m_vexnum=vex.size();
            m_arcs=vector&lt;vector&lt;int&gt;&gt;(m_vexnum,vector&lt;int&gt;(m_vexnum,0));
            m_flags=vector&lt;bool&gt;(m_vexnum,false);
        }

        ////add edge
        void addEdge(int i,int j){
            if(i&lt;0||i&gt;=m_vexnum) throw &quot;index bound exceed&quot;;
            if(j&lt;0||j&gt;=m_vexnum) throw &quot;index bound exxceed&quot;;
            m_arcs[i][j]=1;
            m_arcs[j][i]=1;
        }

        void visit(int i){
            if(i&lt;0||i&gt;=m_vexnum) throw &quot;index bound exceed&quot;;
            cout&lt;&lt;m_vex[i]&lt;&lt;&quot; &quot;;
        } 

        ////traverse
        void traverse(int i){
            if(i&lt;0||i&gt;=m_vexnum) throw &quot;index bound exceed&quot;;
            visit(i);
            for(int j=0;j&lt;m_vexnum;++j){
                if(m_arc[i][j]==1&amp;&amp;m_flags[j]==false) traverse(j);
            }
        }

        ////dfs
        void dfs(){
            for(int i=0;i&lt;m_vexnum;++i){
                if(m_flags[i]==false) traverse(i);
            }
        }   
};

int main(){
    vector&lt;string&gt; vex={&quot;node1&quot;,&quot;node2&quot;,&quot;node3&quot;,&quot;node4&quot;,&quot;node5&quot;,&quot;node6&quot;};
    Graph g(vex);
    g.addEdge(0,1);
    g.addEdge(0,4);
    g.addEdge(0,2);
    g.addEdge(2,3);
    g.addEdge(4,5);
    g.dfs();
    return 0;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/DFS-Of-Graph/" data-id="cka8b3ciw000dokv67yqrhln1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BFS-Of-Graph" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/BFS-Of-Graph/" class="article-date">
  <time datetime="2020-05-15T14:21:49.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/BFS-Of-Graph/">BFS Of Graph</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Conception"><a href="#Conception" class="headerlink" title="Conception"></a>Conception</h2><p>Breath First Search, called BFS, which is one of graphics traversing or searching methods. The basic idea is exploreing as borad as possible of one node from any start node. BFS algorithm can be implementted by a queue, like the level traverse of tree.First of all, we push a node into queue as the start tarverse node of graph, when queue is not empty. We pop each node in queue, access it and find all the neiborhood node of current node, then push them into queue, until queue is empty. after a node is visited, it’s visit flag should be setted as true. </p>
<p>There are two types of grapics storage structures – adjacent matrix storage and adjacency list storage. In this blog, we take adjacent matrix as the storage structure of graphics.</p>
<p>There is a simple implementation of BFS as follows:</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">////DFS</span></span><br><span class="line"><span class="comment">////using adjacent matrix storage</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">////vertices </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m_vex;</span><br><span class="line">    <span class="comment">////arcs</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_arcs;</span><br><span class="line">    <span class="comment">////is visited flag</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; m_flags;</span><br><span class="line">    <span class="comment">////vertex number</span></span><br><span class="line">    <span class="keyword">int</span> m_vexnum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// constructor</span></span><br><span class="line">    Graph(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vex)&#123;</span><br><span class="line">        m_vex=vex;</span><br><span class="line">        m_vexnum=vex.size();</span><br><span class="line">        m_arcs=<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m_vexnum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m_vexnum,<span class="number">0</span>));</span><br><span class="line">        m_flags=<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m_vexnum,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////add edge</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=m_vexnum) <span class="keyword">throw</span> <span class="string">"index bound exceed"</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">0</span>||j&gt;=m_vexnum) <span class="keyword">throw</span> <span class="string">"index bound exxceed"</span>;</span><br><span class="line">        m_arcs[i][j]=<span class="number">1</span>;</span><br><span class="line">        m_arcs[j][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=m_vexnum) <span class="keyword">throw</span> <span class="string">"index bound exceed"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m_vex[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">////traverse</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_vexnum;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m_flags[i])&#123;</span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">                Q.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=Q.size()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">                        <span class="keyword">int</span> cur=Q.top();Q.pop();</span><br><span class="line">                        visit(cur);</span><br><span class="line">                        m_flags[cur]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m_vecnum;++k)&#123;</span><br><span class="line">                         <span class="keyword">if</span>(!m_flags[k]&amp;&amp;m_arcs[j][k]) Q.push(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vex=&#123;<span class="string">"node1"</span>,<span class="string">"node2"</span>,<span class="string">"node3"</span>,<span class="string">"node4"</span>,<span class="string">"node5"</span>,<span class="string">"node6"</span>&#125;;</span><br><span class="line"><span class="function">Graph <span class="title">g</span><span class="params">(vex)</span></span>;</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">g.bfs();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/BFS-Of-Graph/" data-id="cka8b3cir0003okv6dfwv9zig" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Floyd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/Floyd/" class="article-date">
  <time datetime="2020-05-15T14:20:49.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/Floyd/">Floyd</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Conception"><a href="#Conception" class="headerlink" title="Conception"></a>Conception</h2><p>The basic idea of floyd algorithm is very simple, which is based on dynamic programming. If we are going to get the shortest path between vertex i and vertex j, we can get a vertex k as the transfer station, if the path i-&gt;k-&gt;j is shortter than i-&gt;j, update the shortest path of i-&gt;j as i-&gt;k-&gt;j. Meanwhile, we require another matrix to record the path, the path[i][j] is initialized as path[i][j]=i, which means, the shortest path is from i to j. And, if we find a shortter transfer station k, then the path[i][j]=path[k][j].</p>
<h2 id="graph"><a href="#graph" class="headerlink" title="graph"></a>graph</h2><p><img src="https://upload-images.jianshu.io/upload_images/13348038-94dd3a728fb581f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graph(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;s):m_vex(s),m_arcs(s.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.size(),INF)),m_falgs(s.size()),m_vexNum(s.size())&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;m_vexNum||i&lt;<span class="number">0</span>) assert(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;m_vexNum||j&lt;<span class="number">0</span>) assert(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">            m_arcs[i][j]=<span class="number">0</span>;</span><br><span class="line">            m_arcs[j][i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_arcs[i][j]=weight;</span><br><span class="line">        m_arcs[j][i]=weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">paths</span><span class="params">(m_vexNum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m_vexNum,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">shortPaths</span><span class="params">(m_arcs)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_vexNum;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m_vexNum;++j)&#123;</span><br><span class="line">                paths[i][j]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m_vexNum;++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_vexNum;++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m_vexNum;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(shortPaths[i][j]&gt;shortPaths[i][k]+shortPaths[k][j])&#123;</span><br><span class="line">                        shortPaths[i][j]=shortPaths[i][k]+shortPaths[k][j];</span><br><span class="line">                        paths[i][j]=paths[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m_paths=paths;</span><br><span class="line">        m_shorts=shortPaths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_paths.size()!=m_vexNum||m_paths[<span class="number">0</span>].size()!=m_vexNum)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"[error] have not get shortest path"</span>;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_paths[i][j]==i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_vex[i]&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;m_vex[j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_vex[m_paths[i][j]]&lt;&lt;<span class="string">"-&gt;"</span>;</span><br><span class="line">            showPath(m_paths[i][j],j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAllPaths</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_vexNum;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;m_vexNum;++j)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;m_vex[i]&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;m_vex[j]&lt;&lt;<span class="string">" "</span>&lt;&lt;m_shorts[i][j]&lt;&lt;<span class="string">" shortest path is: "</span>;</span><br><span class="line">                showPath(i,j);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_arcs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m_vex;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; m_falgs;</span><br><span class="line">    <span class="keyword">int</span> m_vexNum;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_paths;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_shorts;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nodes=&#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>&#125;;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(nodes)</span></span>;</span><br><span class="line">    g.addEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>,<span class="number">5</span>,<span class="number">16</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>,<span class="number">6</span>,<span class="number">14</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>);</span><br><span class="line">    g.addEdge(<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">    g.addEdge(<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">    g.addEdge(<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">    g.addEdge(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    g.addEdge(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    g.addEdge(<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    g.floyd();</span><br><span class="line">    g.showAllPaths();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>result:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13348038-35ea8f98e47273d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/15/Floyd/" data-id="cka8b3cin0001okv6eqnrdbpp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Introduce-To-Algorithm/" rel="tag">Introduce To Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 13.33px;">C++</a> <a href="/tags/Data-Structure/" style="font-size: 13.33px;">Data Structure</a> <a href="/tags/Introduce-To-Algorithm/" style="font-size: 16.67px;">Introduce To Algorithm</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/network/" style="font-size: 10px;">network</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/26/Quick-Sort/">Quick Sort</a>
          </li>
        
          <li>
            <a href="/2020/05/24/Heap-Sort/">Heap-Sort</a>
          </li>
        
          <li>
            <a href="/2020/05/24/Heap-Sort/">Heap Sort</a>
          </li>
        
          <li>
            <a href="/2020/05/15/What-Compile-Do-When-An-Empty-Class-Is-Declared/">What Compile Do When An Empty Class Is Declared</a>
          </li>
        
          <li>
            <a href="/2020/05/15/Throw-Exception-In-Constructor-And-Destructor/">Throw Exception In Constructor And Destructor</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 BeeCaffe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>