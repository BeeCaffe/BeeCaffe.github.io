<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeeCaffe&#39;s Personal Blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-30T02:27:54.325Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BeeCaffe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Letters and Numbers</title>
    <link href="http://yoursite.com/2020/05/30/Letters-and-Numbers/"/>
    <id>http://yoursite.com/2020/05/30/Letters-and-Numbers/</id>
    <published>2020-05-30T02:18:49.000Z</published>
    <updated>2020-05-30T02:27:54.325Z</updated>
    
    <content type="html"><![CDATA[<p><strong>prefix</strong>: the prefix in an array is a subarray whose length is less than or equal to the length of the array from left to right;</p><p><strong>prefix sum</strong> : the sum of the prefix subarray of an array;</p><p><img src="https://pic.leetcode-cn.com/55450de6bc291cbfb81fd3b47d95d60fc56cb4e5d27899ac83ac4ddcc9632211-12.jpg" alt="12.JPG"></p><p>The general idea is as follows:</p><ul><li><p>since there are only <strong>letter</strong> and <strong>number</strong> in the array, we can write <strong>letter</strong> as -1 and <strong>number</strong> as 1 to simplify the problem.</p></li><li><p>the problem requires the same number of characters and Numbers in the subarray, so we can solve the problem by solving the prefix and. The solution can be divided into two cases:</p><ul><li><ol><li>The values of two prefixes and are the same, for example: prefix[I]==prefix[j], indicating that there are the same number of extra digits or characters between [0, I] and [0,j]. Then if we use the interval [0,j] minus the interval [0, I], the number of digits and characters between [I,j] must be the same, so [(I,j] may be a set of solutions (<strong> note that the interval is left open and right closed </strong>);</li></ol></li><li><ol start="2"><li>Where the prefix[I]=0, for example: prefix[I]=0, the number of Numbers and characters between [0, I] are the same, so [0,j] may be a set of solutions;</li></ol></li></ul></li><li><p>since you need to find the longest subarray and start with the smallest subarray on the left at the same length, you need to find the largest subarray with the <strong> prefix and the same subarray with the </strong> and <strong> prefixes of 0</strong>.</p></li></ul><p>So let’s convert the array to -1 and 1, and figure out all the prefixes and the values of the array;</p><p><img src="https://pic.leetcode-cn.com/53d50d4e8c49a12763fc9cbd6b9693b4b0ccded74c834c606e3d0f088a5d65b9-10.jpg" alt="10.JPG"></p><p>Then, we walk through the prefix and array once, and use a mapping (dictionary) inordered_map to record the value of the prefix and its leftmost subscript;</p><p>Every time we find the prefix and/or the prefix and/or the prefix and/or the sum in the previous example, we update the answer according to the rule.</p><p><img src="https://pic.leetcode-cn.com/16b0e83601c5fbad18778c2a3d635150c4eae4dac1e77a38ce1b44106064be8d-11.jpg" alt="11.JPG"></p><p>As shown in the figure above, the answer to the example given in the question is a subarray from the first prefix and the position of 1 to the last prefix and the position of 1.</p><h3 id="Time-Space"><a href="#Time-Space" class="headerlink" title="Time/Space"></a>Time/Space</h3><p>Time: O (n)</p><p>Space: O (n)</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The class Solution &#123;</span><br><span class="line"></span><br><span class="line">Public:</span><br><span class="line"></span><br><span class="line">The vector &lt; string &gt; findLongestSubarray (vector &lt; string &gt; &amp; array) &#123;</span><br><span class="line"></span><br><span class="line">Int n &#x3D; array. The size ();</span><br><span class="line"></span><br><span class="line">The vector &lt; int &gt; prefix (n, 0);</span><br><span class="line"></span><br><span class="line">Unordered_map &lt; int, int &gt; M; &#x2F; &#x2F; key, left_index</span><br><span class="line"></span><br><span class="line">Int left &#x3D; 0, right &#x3D; 1;</span><br><span class="line"></span><br><span class="line">For (int I &#x3D; 0; I &lt; n. + + I) &#123;</span><br><span class="line"></span><br><span class="line">Char ch &#x3D; array [0] [I];</span><br><span class="line"></span><br><span class="line">If (ch &gt; &#x3D; &#39;A&#39; &amp;&amp; ch &lt; &#x3D; &#39;z&#39;) prefix [I] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">The else prefix [I] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For (int I &#x3D; 1; I &lt; n. + + I) &#123;</span><br><span class="line"></span><br><span class="line">The prefix [I] + &#x3D; prefix [I - 1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For (int I &#x3D; 0; I &lt; n. + + I) &#123;</span><br><span class="line"></span><br><span class="line">Auto it &#x3D; m. ind (prefix [I]);</span><br><span class="line"></span><br><span class="line">If (prefix [I] &#x3D; &#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">If (right - left + 1 &quot;I + 1) &#123;</span><br><span class="line"></span><br><span class="line">Right &#x3D; I; Left &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">If (it &#x3D; &#x3D; M.e nd () M [prefix [I]] &#x3D; I;</span><br><span class="line"></span><br><span class="line">The else &#123;</span><br><span class="line"></span><br><span class="line">If (right - left + 1 &lt; I - it - &gt; second) &#123;</span><br><span class="line"></span><br><span class="line">Right &#x3D; I; Left &#x3D; it - &gt; second + 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The vector &lt; string &gt; ans.</span><br><span class="line"></span><br><span class="line">For (int I &#x3D; left; I &lt; &#x3D; right; + + I) ans. Push_back (array [I]);</span><br><span class="line"></span><br><span class="line">Return ans.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;prefix&lt;/strong&gt;: the prefix in an array is a subarray whose length is less than or equal to the length of the array from left to 
      
    
    </summary>
    
    
      <category term="Cracking the Coding Interview" scheme="http://yoursite.com/tags/Cracking-the-Coding-Interview/"/>
    
  </entry>
  
  <entry>
    <title>Count Sort</title>
    <link href="http://yoursite.com/2020/05/28/Count-Sort/"/>
    <id>http://yoursite.com/2020/05/28/Count-Sort/</id>
    <published>2020-05-28T01:14:32.000Z</published>
    <updated>2020-05-28T02:28:20.815Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Count Sort</strong> bases on the condition that all elements of waiting to sort are belong to a range in [0,k]. For example, <strong>nums={2,5,3,0,2,3,0,3}</strong>, all elements in <strong>nums</strong> are limited in range form 0 to 7, so k=7 for <strong>nums</strong>. (This is a very improtant condition for count sort, if array does not statisfy this priciple, count sort can not be used.)</p><p>The basic idea of Count Sort is: for each elements x, supposing we know how many element smaller than x we can put x to the correct place directly.</p><p>However, how can we know how many elements samller than x in nums? Inorder to know that, we can build a new array, which we call <strong>countArray</strong> to count each element occurs times in nums. Then, we traver <strong>countArray</strong> from begin to end to accumulate the value in <strong>countArray</strong>, after that, the elements in <strong>countArray</strong> are the correct index of sorted value of array <strong>nums</strong>. Traveing array <strong>nums</strong> and using <strong>countArray</strong> to find the correct location for ecah value in <strong>nums</strong> and put it to result array <strong>outputArray</strong>. </p><p>And, notice that, there are same element exist in <strong>nums</strong>. Therefore, when we put a <strong>nums</strong> value to <strong>outputArray</strong>, <strong>countArray[nums[i]]–</strong> should be performed, after that, when next <strong>nums[i]</strong> value occurs in <strong>nums</strong>, this value can be  putted to correct location.</p><h2 id="Diagram"><a href="#Diagram" class="headerlink" title="Diagram"></a>Diagram</h2><p><img src="/images/4.jpg" alt="image"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countArray</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//counting occur times of each element in nums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) countArray[i]++;</span><br><span class="line">    <span class="comment">//accumulating the correct location of each element</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;countArray.size();++i)&#123;</span><br><span class="line">        countArray[i]=countArray[i]+countArray[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put nums element to correct location in outputArray</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">outputArray</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        outputArray[countArray[nums[i]]]=nums[i];</span><br><span class="line">        countArray[nums[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums=outputArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    count_sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h2><p><strong>Count Sort</strong> is not a comparsion based sorting algorithm, thus, althought it’s condition is strictliy than comparsion based sorting method, it has a fater time complextiy. In this algorithm, we only travel the array without back trace operation, so the time complexity is <strong>O(n)</strong>, which is better than <strong>O(nlog(n))</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Count Sort&lt;/strong&gt; bases on the condition that all elements of waiting to sort are belong to a range in [0,k]. For example, &lt;str
      
    
    </summary>
    
    
      <category term="Introduce To Algorithm" scheme="http://yoursite.com/tags/Introduce-To-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信IPC</title>
    <link href="http://yoursite.com/2020/05/27/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1IPC/"/>
    <id>http://yoursite.com/2020/05/27/进程间通信IPC/</id>
    <published>2020-05-27T06:47:44.000Z</published>
    <updated>2020-05-27T07:02:12.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通讯方式以及优点缺点"><a href="#进程间通讯方式以及优点缺点" class="headerlink" title="进程间通讯方式以及优点缺点"></a>进程间通讯方式以及优点缺点</h3><hr><p>进程间通信方式包括：信号，信号量，管道，共享内存，消息队列，套接口。</p><ul><li><strong>管道（piepe）</strong><ul><li>有名管道：一种半双工的进程间通讯方式，允许无亲缘关系的进程间通讯。<ul><li>优点：可以实现任意关系进程间的通信</li><li>缺点：a. 长期存在于系统中，使用不当易出错               b. 缓冲区有限</li></ul></li><li>无名管道：一种半双工的进程间通讯方式，只允许有亲缘关系的进程间进行通讯（父子进程）<ul><li>优点：简单方便</li><li>缺点：a. 局限于单向通讯 b. 只适用于有亲缘关系的父子进程 c. 缓冲区有限</li></ul></li></ul></li></ul><p><img src="/images/2.png" alt="image"></p><ul><li><p><strong>信号量（semaphore）</strong>：一个计数器，可以控制多个线程对共享资源的访问。</p><ul><li>举例：一个房间里面有多个妹子，可以多个嫖客同时进入。当房间人数达到上限时，嫖客将自己名字登记在门前列表上，并开始打盹。当房间里面有人出来的时候，负责唤醒打盹的嫖客</li><li>优点： 可以同步进程</li><li>缺点： 信号量有限</li></ul></li><li><p><strong>信号（signal）</strong>：信号是 Linux 进程间通信的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式   。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p><ul><li>举例：“ 中断 ” 在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给 “ 中断 ” 了，我去签收快递 ( 处理中断 ) ，处理完成后，再继续玩我的游戏。这里我们学习的 “ 信号 ” 就是属于这么一种 “ 中断 ” 。我们在终端上敲 “Ctrl+c” ，就产生一个 “ 中断 ” ，相当于产生一个信号，接着就会处理这么一个 “ 中断任务 ” （默认的处理方式为中断当前进程）。</li><li><strong>信号本质</strong> 信号的本质是操作系统给进程发送信号，即向进程的PCB（Process Control Block）中写入数据，修改相应的PCB字段，进程在合适的时间去处理所接受到的信号。使用信号的目的大致分为两点：a. 让进程知道已经发生某个特定事件 b. 强迫代码执行其代码中的信号处理程序。</li><li><strong>信号分类</strong><ul><li>用户终端输入：Ctrl+c，Ctrl+\，Ctrl+z</li><li>硬件异常：进程访问非法内存，除以0</li><li>kill（）函数发送信号</li></ul></li><li><strong>信号处理方式</strong><ul><li>执行系统默认： 终止该进程</li><li>忽略信号：没有任何动作</li><li>执行自定义函数</li></ul></li></ul></li><li><p><strong>消息队列</strong>：是位于内核的消息链表，每个节点都是一个消息，每一个消息都有自己的类型，由消息队列标识符标识，每种类型的消息都被对应链表维护。<br><img src="/images/3.png" alt="image"></p><ul><li>图中 1，2，3，4 代表消息类型，彩色方块代表消息。0维护整个消息队列，记录每个消息加入队列的事件。</li></ul><ul><li><strong>优点</strong>：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li><strong>缺点</strong>： 信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li><p><strong>共享内存</strong>：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问</p><ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：a. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 b. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程间通讯方式以及优点缺点&quot;&gt;&lt;a href=&quot;#进程间通讯方式以及优点缺点&quot; class=&quot;headerlink&quot; title=&quot;进程间通讯方式以及优点缺点&quot;&gt;&lt;/a&gt;进程间通讯方式以及优点缺点&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;进程间通信方式包括：信号，信号量，管道，共
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Quick Sort</title>
    <link href="http://yoursite.com/2020/05/26/Quick-Sort/"/>
    <id>http://yoursite.com/2020/05/26/Quick-Sort/</id>
    <published>2020-05-26T02:55:42.000Z</published>
    <updated>2020-05-26T02:59:53.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Quick-Sort"><a href="#1-Quick-Sort" class="headerlink" title="1. Quick Sort"></a>1. Quick Sort</h3><p>For each time, we ensure one numbers location in the whole array, which we called <strong>key value</strong>, then, we put the numbers which smaller than key value into the left of it, and the bigger number to the right of key value.</p><p>After that, we recurrently ensure the left numbers order and the right numbers order until the whole array are sorted.The following picture shows a simple example of quickly sort.</p><p><img src="https://upload-images.jianshu.io/upload_images/13348038-4b3fb69926be987e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="quick_sort.jpg"></p><p>At the start of this program, <strong>low=0</strong> and <strong>high=5</strong>, we choose the first number of the range of [low,high], and use a variable <strong>key=arr[low]=7</strong> to record this number. Then we find that arr[high]=2 &lt; 7, which means we must change the high index number to key value left. As a result for we have recorded the arr[low] in<strong> key</strong>, we set arr[low]=arr[high].</p><p>Then, we need to find the first bigger than key number in the left of the key. As we can see 8 is bigger than 7, so we stop and set arr[high]=arr[low].</p><p>In a word, we try to find the number smaller than key in the right and swap it into the left, by contrast, we search the value bigger than key in the left and swap it into right, until high==low, we set arr[high]=arr[low]=key. Then we do the same thing in the left subrange and right subrange.</p><p>The source code of this algorithm is shown in following.</p><h3 id="2-Code"><a href="#2-Code" class="headerlink" title="2. Code"></a>2. Code</h3><pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="function"><span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{    <span class="keyword">int</span> key=nums[low];    <span class="comment">//when low==high, loop is over</span>    <span class="keyword">while</span>(low&lt;high){        <span class="comment">//we must find the first number of smaller than key in the right of the key</span>        <span class="keyword">while</span>(low&lt;high&amp;&amp;nums[high]&gt;=key) --high;        nums[low]=nums[high];        <span class="comment">//we must find the first number of bigger than key in the left</span>        <span class="keyword">while</span>(low&lt;high&amp;&amp;nums[low]&lt;=key) ++low;        nums[high]=nums[low];    }    <span class="comment">//there is key place</span>    nums[low]=key;    <span class="keyword">return</span> low;}<span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{    <span class="keyword">if</span>(low&lt;high){        <span class="keyword">int</span> index=get_index(nums,low,high);        quick_sort(nums,low,index<span class="number">-1</span>);        quick_sort(numsd,index+<span class="number">1</span>,high);    }}<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{    <span class="keyword">int</span> n;    <span class="built_in">cin</span>&gt;&gt;n;    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i){        <span class="keyword">int</span> val;        <span class="built_in">cin</span>&gt;&gt;val;        nums.push_back(val);    }    quick_sort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre><h3 id="3-Complexity"><a href="#3-Complexity" class="headerlink" title="3. Complexity"></a>3. Complexity</h3><p><strong>Time complexity</strong>:For each time we must change value n times, and the stack deep is logn, so the time complexity is <strong>O**</strong>(nlogn)**. In the worst situation, the stack deepth changed into n, the time complexity would be O(n2).</p><p><strong>Space Complexity</strong>: O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Quick-Sort&quot;&gt;&lt;a href=&quot;#1-Quick-Sort&quot; class=&quot;headerlink&quot; title=&quot;1. Quick Sort&quot;&gt;&lt;/a&gt;1. Quick Sort&lt;/h3&gt;&lt;p&gt;For each time, we ensure one
      
    
    </summary>
    
    
      <category term="Introduce To Algorithm" scheme="http://yoursite.com/tags/Introduce-To-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Heap-Sort</title>
    <link href="http://yoursite.com/2020/05/24/Heap-Sort/"/>
    <id>http://yoursite.com/2020/05/24/Heap-Sort/</id>
    <published>2020-05-24T02:57:35.272Z</published>
    <updated>2020-05-24T02:57:35.273Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head>      <title>Heap Sort</title>      <meta charset="utf-8">      <meta name="viewport" content="width=device-width, initial-scale=1.0">            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">                                                            <style>      /** * prism.js Github theme based on GitHub's theme. * @author Sam Clarke */code[class*="language-"],pre[class*="language-"] {  color: #333;  background: none;  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;  text-align: left;  white-space: pre;  word-spacing: normal;  word-break: normal;  word-wrap: normal;  line-height: 1.4;  -moz-tab-size: 8;  -o-tab-size: 8;  tab-size: 8;  -webkit-hyphens: none;  -moz-hyphens: none;  -ms-hyphens: none;  hyphens: none;}/* Code blocks */pre[class*="language-"] {  padding: .8em;  overflow: auto;  /* border: 1px solid #ddd; */  border-radius: 3px;  /* background: #fff; */  background: #f5f5f5;}/* Inline code */:not(pre) > code[class*="language-"] {  padding: .1em;  border-radius: .3em;  white-space: normal;  background: #f5f5f5;}.token.comment,.token.blockquote {  color: #969896;}.token.cdata {  color: #183691;}.token.doctype,.token.punctuation,.token.variable,.token.macro.property {  color: #333;}.token.operator,.token.important,.token.keyword,.token.rule,.token.builtin {  color: #a71d5d;}.token.string,.token.url,.token.regex,.token.attr-value {  color: #183691;}.token.property,.token.number,.token.boolean,.token.entity,.token.atrule,.token.constant,.token.symbol,.token.command,.token.code {  color: #0086b3;}.token.tag,.token.selector,.token.prolog {  color: #63a35c;}.token.function,.token.namespace,.token.pseudo-element,.token.class,.token.class-name,.token.pseudo-class,.token.id,.token.url-reference .token.variable,.token.attr-name {  color: #795da3;}.token.entity {  cursor: help;}.token.title,.token.title .token.punctuation {  font-weight: bold;  color: #1d3e81;}.token.list {  color: #ed6a43;}.token.inserted {  background-color: #eaffea;  color: #55a532;}.token.deleted {  background-color: #ffecec;  color: #bd2c00;}.token.bold {  font-weight: bold;}.token.italic {  font-style: italic;}/* JSON */.language-json .token.property {  color: #183691;}.language-markup .token.tag .token.punctuation {  color: #333;}/* CSS */code.language-css,.language-css .token.function {  color: #0086b3;}/* YAML */.language-yaml .token.atrule {  color: #63a35c;}code.language-yaml {  color: #183691;}/* Ruby */.language-ruby .token.function {  color: #333;}/* Markdown */.language-markdown .token.url {  color: #795da3;}/* Makefile */.language-makefile .token.symbol {  color: #795da3;}.language-makefile .token.variable {  color: #183691;}.language-makefile .token.builtin {  color: #0086b3;}/* Bash */.language-bash .token.keyword {  color: #0086b3;}/* highlight */pre[data-line] {  position: relative;  padding: 1em 0 1em 3em;}pre[data-line] .line-highlight-wrapper {  position: absolute;  top: 0;  left: 0;  background-color: transparent;  display: block;  width: 100%;}pre[data-line] .line-highlight {  position: absolute;  left: 0;  right: 0;  padding: inherit 0;  margin-top: 1em;  background: hsla(24, 20%, 50%,.08);  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));  pointer-events: none;  line-height: inherit;  white-space: pre;}pre[data-line] .line-highlight:before, pre[data-line] .line-highlight[data-end]:after {  content: attr(data-start);  position: absolute;  top: .4em;  left: .6em;  min-width: 1em;  padding: 0 .5em;  background-color: hsla(24, 20%, 50%,.4);  color: hsl(24, 20%, 95%);  font: bold 65%/1.5 sans-serif;  text-align: center;  vertical-align: .3em;  border-radius: 999px;  text-shadow: none;  box-shadow: 0 1px white;}pre[data-line] .line-highlight[data-end]:after {  content: attr(data-end);  top: auto;  bottom: .4em;}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}/* Please visit the URL below for more information: *//*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */      </style>    <meta name="generator" content="Hexo 4.2.1"></head>    <body for="html-export">      <div class="mume markdown-preview  ">            </div>                                                  </body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;
      &lt;title&gt;Heap Sort&lt;/title&gt;
      &lt;meta charset=&quot;utf-8&quot;&gt;
      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-wi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Heap Sort</title>
    <link href="http://yoursite.com/2020/05/24/Heap-Sort/"/>
    <id>http://yoursite.com/2020/05/24/Heap-Sort/</id>
    <published>2020-05-24T02:39:55.000Z</published>
    <updated>2020-05-25T03:02:21.892Z</updated>
    
    <content type="html"><![CDATA[<p>Actually, Heap is an array which is a complete binary tree in logical, excepting for the lowest layer all the layers are full binary tree. There are two types of heap, they are top heap and bottom heap. In heap sort algorithm we utilize top heap, and bottom heap is used to construct priority queue in gennerally. </p><p>Suppose heap node i, it parent is i-1/2, we can define top heap and bottom heap as follows: </p><ul><li><strong>Top Heap</strong>: heap[(i-1)/2]&gt;=heap[i]</li><li><strong>Bottom Heap</strong>: heap[(i-1)/2]&lt;=heap[i]</li></ul><h2 id="Adjust-Heap"><a href="#Adjust-Heap" class="headerlink" title="Adjust Heap"></a>Adjust Heap</h2><p>This place I use top heap as an example, top heap must satisify the priciple of heap[(i-1)/2]&gt;=heap[i]. Therefore, we must make sure all the elements in heap satisfiy this relu.<br>We know that, the child of node i are 2<em>i+1 and 2</em>i+2, that is:</p><ul><li><strong>Left Child</strong>: 2*i+1</li><li><strong>Right Child</strong>: 2*i+2<br>We must make sure every elements in heap satisfy the font relue. Therefore, if heap[i]&lt;heap[left_child] or heap[i]&lt;heap[right_child], we should swap heap[i] with min(heap[left_child],heap[right_child]). Then, taking this operation recurrently. The code of adjust heap is as following:</li><li><strong>code</strong>:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap,<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">2</span>*i+<span class="number">1</span>,right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> minNum=heap[i],minIdx=i;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;n &amp;&amp; minNum&gt;heap[left])&#123;</span><br><span class="line">        minNum=heap[left];</span><br><span class="line">        minIdx=left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;n &amp;&amp; minNum&gt;heap[right])&#123;</span><br><span class="line">        minNum=heap[right];</span><br><span class="line">        minIdx=right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minIdx!=i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=heap[i];</span><br><span class="line">        heap[i]=minNum;</span><br><span class="line">        heap[minIdx]=tmp;</span><br><span class="line">        adjustHeap(heap,minIdx,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>generally, for a heap the time complexity of adjusting a heap is O(logn).</li></ul><h2 id="Bild-Heap"><a href="#Bild-Heap" class="headerlink" title="Bild Heap"></a>Bild Heap</h2><p>A heap can be bulit by a bottom-up process, where is to tranfer a normal array with length n to a heap. </p><p>Why we choose bottom-up process rather than top-down process to build a heap?</p><p>If we choose top-down process to build a heap, the strat point must be the root node. When strarting to adjust the heap form root, the sub-tree of root are not satisty the heap rules, so, the build heap process may meet some problem. By constrast, if we choose bottom-up process to build a heap, before adjusting the top node, their children has already been adjusted. Therefore, the code of build heap is:</p><ul><li><strong>code</strong>:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=heap.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) adjustHeap(heap,i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>The time complexity of build heap is O(n), more detail about the time complexity please refer to book.<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2>As a result for the root is alway the maximum elements in the heap. Thus, for each time, we can get the maximum value, and swap it with the last value in the heap. Then, adjusting the heap again to get the next maximum value. After n steps, all the elements in the heap is ordered. The code is:</li><li><p><strong>code</strong>:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    buildHeap(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;++i)&#123;</span><br><span class="line">        swap(heap[<span class="number">0</span>],heap[i]);</span><br><span class="line">        adjustHeap(heap,<span class="number">0</span>,i);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>The complete code of heap sort is as following:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap,<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">2</span>*i+<span class="number">1</span>,right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> minNum=heap[i],minIdx=i;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;n &amp;&amp; minNum&gt;heap[left])&#123;</span><br><span class="line">        minNum=heap[left];</span><br><span class="line">        minIdx=left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;n &amp;&amp; minNum&gt;heap[right])&#123;</span><br><span class="line">        minNum=heap[right];</span><br><span class="line">        minIdx=right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minIdx!=i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=heap[i];</span><br><span class="line">        heap[i]=minNum;</span><br><span class="line">        heap[minIdx]=tmp;</span><br><span class="line">        adjustHeap(heap,minIdx,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=heap.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) adjustHeap(heap,i,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    buildHeap(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;++i)&#123;</span><br><span class="line">        swap(heap[<span class="number">0</span>],heap[i]);</span><br><span class="line">        adjustHeap(heap,<span class="number">0</span>,i);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    heapSort(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Actually, Heap is an array which is a complete binary tree in logical, excepting for the lowest layer all the layers are full binary tree
      
    
    </summary>
    
    
      <category term="Introduce To Algorithm" scheme="http://yoursite.com/tags/Introduce-To-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>What Compile Do When An Empty Class Is Declared</title>
    <link href="http://yoursite.com/2020/05/15/What-Compile-Do-When-An-Empty-Class-Is-Declared/"/>
    <id>http://yoursite.com/2020/05/15/What-Compile-Do-When-An-Empty-Class-Is-Declared/</id>
    <published>2020-05-15T14:37:01.000Z</published>
    <updated>2020-05-15T14:37:38.231Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>conclusion</strong>: when an empty class is declared, the compile will generate some members by default.<br>(1) default constructor;<br>(2) copy constructor;<br>(3) operator=();<br>(4) default destructor;</li><li><strong>code</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; the mepty class</span><br><span class="line">class Empty&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;euqal to following</span><br><span class="line">class Empty&#123;</span><br><span class="line">public:</span><br><span class="line">    Empty()&#123;&#125;;</span><br><span class="line">    Empty(const Empty&amp;)&#123;&#125;;</span><br><span class="line">    Empty&amp; operator&#x3D;(const Empty&amp;)&#123;return *this&#125;;</span><br><span class="line">    inline ~Empty()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="if-user-declares-a-constructor-the-compile-will-not-generate-default-constructor"><a href="#if-user-declares-a-constructor-the-compile-will-not-generate-default-constructor" class="headerlink" title="if user declares a constructor, the compile will not generate default constructor"></a>if user declares a constructor, the compile will not generate default constructor</h2></li><li><strong>explaination</strong>: when a constrcutor is decalred in C++, the compile will not generate default constructor any more. Due to compile regards you do not need a default constructor anymore.</li><li><strong>code</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; the mepty class</span><br><span class="line">class Empty&#123;</span><br><span class="line"> public:</span><br><span class="line">    Empty(int val):m_data(val)&#123;&#125;</span><br><span class="line">  private:</span><br><span class="line">    int m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;equals to following</span><br><span class="line">class Empty&#123;</span><br><span class="line">public:</span><br><span class="line">    Empty(int val):m_data(val)&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;Empty()&#123;&#125;;</span><br><span class="line">    Empty(const Empty&amp;)&#123;&#125;;</span><br><span class="line">    Empty&amp; operator&#x3D;(const Empty&amp;)&#123;return *this&#125;;</span><br><span class="line">    inline ~Empty()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: when an empty class is declared, the compile will generate some members by default.&lt;br&gt;(1) default con
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Throw Exception In Constructor And Destructor</title>
    <link href="http://yoursite.com/2020/05/15/Throw-Exception-In-Constructor-And-Destructor/"/>
    <id>http://yoursite.com/2020/05/15/Throw-Exception-In-Constructor-And-Destructor/</id>
    <published>2020-05-15T14:35:57.000Z</published>
    <updated>2020-05-15T14:36:23.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-will-happen-if-throw-a-exception-in-constructor"><a href="#What-will-happen-if-throw-a-exception-in-constructor" class="headerlink" title="What will happen if throw a exception in constructor?"></a>What will happen if throw a exception in constructor?</h2><ul><li><strong>Conculsion</strong>: Throwing an exception in constructor may case two problem:<br>(1) The destructor of this Class can not be called;<br>(2) Memory leaky;</li><li><strong>Explain</strong>:<br>As the following code, class ObjectA is a base class which is inherient by class Normal.Meanwhile, there is also another class, class Evil, which has throwed an exception in constructor. Class Normal has a member variable of Class Evil. In the constructor of Class Normal, when the constructor is called, there are four member should be constrcut, their are  m_a,m_evil,m_resource and m_value in Class ObjectA. In Class Normal, m_a,m_resource and m_value have been constructed correctly, however when compile attempts to construct m_evil, there has throwed and exception.It cause the construction of Class Normal has been stopped, thus, Class Normal’s destructor can not be called correctly and m_resource can not be delete. So, there is a memory leaky in this code.</li><li><strong>Code</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class ObjectA&#123;</span><br><span class="line">    public:</span><br><span class="line">        explicit ObjectA(int a):m_value(new int(a))&#123;&#125;</span><br><span class="line">    private:</span><br><span class="line">        int *m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Throw a exception in Class Evil</span><br><span class="line">class Evil&#123;</span><br><span class="line">    public:</span><br><span class="line">        Evil()&#123;throw 10;&#125;;</span><br><span class="line">        ~Evil()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;destructor can not be called, and m_resource can not be delete, which causes memory leaky.</span><br><span class="line">class Normal:public ObjectA&#123;</span><br><span class="line">    public:</span><br><span class="line">        explicit Normal(int a):ObjectA(a), m_a(a+1),m_resource(new int(a+2))&#123;&#125;</span><br><span class="line">        ~Normal()&#123;delete m_resource;&#125;</span><br><span class="line">    private:</span><br><span class="line">        ObjectA m_a;</span><br><span class="line">        Evil m_evil;</span><br><span class="line">        int *m_resource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void hasMemoryLeak()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Normal n(1);</span><br><span class="line">    &#125;catch(...)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    hasMemoryLeak();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;What-will-happen-if-throw-a-exception-in-constructor&quot;&gt;&lt;a href=&quot;#What-will-happen-if-throw-a-exception-in-constructor&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>bind And function In C++</title>
    <link href="http://yoursite.com/2020/05/15/bind-And-function-In-C/"/>
    <id>http://yoursite.com/2020/05/15/bind-And-function-In-C/</id>
    <published>2020-05-15T14:34:51.000Z</published>
    <updated>2020-05-15T14:36:20.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function()"></a>std::function()</h2><p>There are four types callable objects in C++ in total.</p><ul><li>function</li><li>lambda expression</li><li>overload operator() class </li><li>std::function() object or funtion pointer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;example of callable object in C++</span><br><span class="line">&#x2F;&#x2F; function</span><br><span class="line">int add(int a, int b)&#123;return a+b;&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; lambda expression</span><br><span class="line">auto mod &#x3D; [](int a, int b)&#123; return a % b;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; calss with overloading operator()</span><br><span class="line">struct divide&#123;</span><br><span class="line">    int operator()(int denominator, int divisor)&#123;</span><br><span class="line">        return denominator&#x2F;divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>We can reserve the front callable object in std::funtion(), as following:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)&gt;  a = add; </span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)&gt;  b = mod ; </span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> ,<span class="keyword">int</span>)&gt;  c = divide();</span><br></pre></td></tr></table></figure><p>Therefore, std::function() is able to save function, lambda expression, function pointer and class with overloading operator(). Generally, std::function() is utilized as callback function to delay the function running time.</p><h2 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind()"></a>std::bind()</h2><p>As we know the function always has arguments list, and std::function is able to bind callable object with arguments. The result of std::bind() is able to save by std::function().</p><ul><li><strong>bind with function</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholder::_1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//with out place holder</span></span><br><span class="line"><span class="keyword">auto</span> cb=<span class="built_in">std</span>::bind(sum,<span class="number">21</span>,<span class="number">23</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cb()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//with place holder</span></span><br><span class="line"><span class="keyword">auto</span> cb=<span class="built_in">std</span>::bind(sum,<span class="number">21</span>,_1);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cb(<span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>bind arguments to a void() function</strong></p><p>  Using std::function() and std::bind(), we can bind any numbers of  arguments with a std::function&lt;void()&gt; functor.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind std::function&lt;void(int,int)&gt; to a std::function&lt;void()&gt;</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb;</span><br><span class="line">cb=<span class="built_in">std</span>::bind(sum,<span class="number">10</span>,<span class="number">12</span>);</span><br><span class="line">cb();</span><br></pre></td></tr></table></figure></li><li><p><strong>bind with member function</strong></p><p>  If you suppose to bind a member function, you need to bind three parts:</p><ul><li>Member function reference, e.g. &amp;Sum::sum</li><li>Object reference, e.g. &amp;s</li><li>arguments.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using std::placeholders::_1;</span><br><span class="line">class Sum&#123;</span><br><span class="line">public:</span><br><span class="line">    void sum(int a,int b)&#123;</span><br><span class="line">    cout&lt;&lt;a+b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Sum s;</span><br><span class="line">    std::function&lt;void()&gt; cb;</span><br><span class="line">    &#x2F;&#x2F;bind class Sum function sum.</span><br><span class="line">    cb&#x3D;std::bind(&amp;Sum::sum,&amp;s,10,15);</span><br><span class="line">    cb();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>bind with lambda</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lbda=[](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> cb = <span class="built_in">std</span>::bind(lbda,<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line">    cb();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Rerference"><a href="#Rerference" class="headerlink" title="Rerference"></a>Rerference</h2><p>[1] <a href="https://www.jianshu.com/p/f191e88dcc80" target="_blank" rel="noopener">https://www.jianshu.com/p/f191e88dcc80</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Variable Arguments In C++</title>
    <link href="http://yoursite.com/2020/05/15/Variable-Arguments-In-C/"/>
    <id>http://yoursite.com/2020/05/15/Variable-Arguments-In-C/</id>
    <published>2020-05-15T14:33:34.000Z</published>
    <updated>2020-05-15T14:33:53.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-what-is-variable-arguments"><a href="#1-what-is-variable-arguments" class="headerlink" title="1. what is variable arguments?"></a>1. what is variable arguments?</h2><p>In C\C++ program we always need some functions which arguments number are variable, such as <strong>printf()</strong> and <strong>scanf()</strong>. We called those function as variable arguments function and we use placeholder <strong>…</strong> to represent the uncertained[1]. arguments.</p><pre><code>int printf(const char* fmt, ...);int scanf(const char* fmt, ...);</code></pre><p>And, there is an simple example of variable arguments:</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdarg&gt;/* * @brief : The purpose of this function is to print any number of integer, * @param[in] count : The number of int you suppose to print. * @param[in] ... : variable arguments. */int print_args(int count, ...){    int i,value;    //// the pointer of arguments address    va_list arg_ptr;    //// get address of first argument    va_start(arg_ptr, count);    for(int i=0; i&lt;count; ++i){        //// get the next argument address        value = va_arg(arg_ptr,int);        printf(&quot;position %d=%d\n&quot;,i+1,value);    }    //// set arg_ptr yo 0    va_end(arg_ptr);}int main() {    print_args(5,1,2,3,4,5);    return 0;}</code></pre><h2 id="2-The-macros-of-va-list-va-start-va-arg-and-va-end"><a href="#2-The-macros-of-va-list-va-start-va-arg-and-va-end" class="headerlink" title="2. The macros of va_list, va_start, va_arg and va_end"></a>2. The macros of va_list, va_start, va_arg and va_end</h2><p>Those types are used as parameters for the macros defined in <cstdarg> to retrieve the additional arguments of a function[2].</p><p><strong>va_list</strong> The type to hold information about variable arguments [2].</p><p><strong>va_start(va_list,paramN)</strong> Initialize a variable argument list. Initailizes <strong>va_list</strong> type pointer to retrieve the additional arguments after paramN[2].</p><p><strong>va_arg(va_list, type)</strong> Retrieve next argument.</p><p><strong>va_end(va_list)</strong> End using variable argument list, set va_list type argument to nullptr.</p><p>We can illustrate the upper for loop as the following picture:</p><p><img src="https://upload-images.jianshu.io/upload_images/13348038-c8913e90783c0b8f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="va_list.jpg"><br>45B0883250139C6D9A27)</p><p>when we call <strong>va_start(arg_ptr,count)</strong>, the arg_ptr has been set to the start address of variable arguments list. Then, the <strong>va_arg(arg_ptr,int)</strong> function move the arg_ptr pointer. In the end, we set arg_ptr to zero.</p><h2 id="3-vsprintf-char-str-const-char-format-va-list-arg"><a href="#3-vsprintf-char-str-const-char-format-va-list-arg" class="headerlink" title="3. vsprintf(char str, const char format, va_list arg)"></a>3. vsprintf(char<em> str, const char</em> format, va_list arg)</h2><p>There is a utilization of variable arguments or said va_list, that is function <strong>vsprintf()</strong>, this function is able to print variable arguments in a suitable format.</p><p><strong> str </strong> the char* pointer, point to char[] where we suppose to print.</p><p><strong>format</strong> the contorl format of string, such as “%d,%f,%n” …</p><p><strong>arg</strong> va_list type argument which points to the start position of variable arguments list.</p><p>There is a example to utilize va_list and vsprintf()<strong>[3]</strong> :</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdarg.h&gt;char buffer[80];int vspfunc(char* format, ...){    va_list arg;    int ans;    va_start(arg,format);    ans = vsprintf(buffer,format,arg);    va_end(arg);    return ans;}int main(){    int i = 5;    float f = 27.0;    char str[50] = &quot;runoob.com&quot;;    vspfunc(&quot;%d %f %s&quot;,i,f,str);    printf(&quot;%s\n&quot;,buffer);    return 0;}</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.cnblogs.com/zlcxbb/p/6802895.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlcxbb/p/6802895.html</a><br>[2] <a href="http://www.cplusplus.com/reference/cstdarg/va_list/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cstdarg/va_list/</a><br>[3] <a href="https://www.runoob.com/cprogramming/c-function-vsprintf.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-vsprintf.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-what-is-variable-arguments&quot;&gt;&lt;a href=&quot;#1-what-is-variable-arguments&quot; class=&quot;headerlink&quot; title=&quot;1. what is variable arguments?&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Install Boost In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Install-Boost-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Install-Boost-In-Linux/</id>
    <published>2020-05-15T14:32:34.000Z</published>
    <updated>2020-05-15T14:32:57.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Fast-install"><a href="#1-Fast-install" class="headerlink" title="1. Fast install"></a>1. Fast install</h2><p>Typing the following command in linux console to install boost dirtectly.</p><p><strong>Notes</strong>: you’d best add <strong>sudo</strong> before you command to aviod premission deny especially in system level path.</p><pre><code>wget https://dl.bintray.com/boostorg/release/1.72.0/source/boost_1_72_0.tar.gztar -xzvf boost_1_54_0.tar.gzcd boost_1_54_0./bootstrap.sh --prefix=/usr/local./b2 install --with=all## you can find boost library in /usr/local/lib.</code></pre><h2 id="2-Test-example"><a href="#2-Test-example" class="headerlink" title="2. Test example"></a>2. Test example</h2><p>There is an test example of boost libray, you just need to copy the soucure code of the following program and compile this source code:</p><ul><li><p><strong>command</strong></p><pre><code>vim boost_test.ccg++ boost_test.cc -L/usr/local/lib -lboost_system./a.out</code></pre></li><li><p><strong>source code</strong></p><pre><code>#include &lt;boost/lexical_cast.hpp&gt;#include &lt;iostream&gt;int main(){        using boost::lexical_cast;        int a = lexical_cast&lt;int&gt;(&quot;123&quot;);        double b = lexical_cast&lt;double&gt;(&quot;123.12&quot;);        std::cout&lt;&lt;a&lt;&lt;std::endl;        std::cout&lt;&lt;b&lt;&lt;std::endl;        return 0;}</code></pre></li><li><p><strong>output</strong></p><pre><code>123123.12</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Fast-install&quot;&gt;&lt;a href=&quot;#1-Fast-install&quot; class=&quot;headerlink&quot; title=&quot;1. Fast install&quot;&gt;&lt;/a&gt;1. Fast install&lt;/h2&gt;&lt;p&gt;Typing the following
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP Three Way Handshake</title>
    <link href="http://yoursite.com/2020/05/15/TCP-Three-Way-Handshake/"/>
    <id>http://yoursite.com/2020/05/15/TCP-Three-Way-Handshake/</id>
    <published>2020-05-15T14:31:35.000Z</published>
    <updated>2020-05-15T14:32:04.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-TCP-Header-Format"><a href="#1-TCP-Header-Format" class="headerlink" title="1. TCP Header Format"></a>1. TCP Header Format</h2><p>As is shown in the following picture, the TCP header has 20 Bytes in total.</p><p><img src="https://upload-images.jianshu.io/upload_images/13348038-e096bec9fa7edcef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p><strong>Port Number</strong>: Each TCP segment includes source port number and destination port number, which respectively refers to the TCP segment sender’s and receiver’s address. Notes to mention that, here we utilizes “port” rather than “address”, that is said TCP answer for application layer and itself belong to tranport layer. Meanwhile, the combination of “port” and “IP address” is called socket, which is able to ensure a specific program in a computer. </p></li><li><p><strong>Sequence Number</strong>: Behind source and destination port, 32 bits have been utilized to reserver sequence number, which is randomlly produced during Three-Way Handshake process and used to ensure the correction of the TCP segment order. TCP is an order protocal, and the sequence number is used to make sure TCP message can be sequential sent to another computer’s application layer.</p></li><li><strong>Acknowledgement Number</strong>: Then, there is 32 bits Ackknowledgement Number in TCP Header. We call it as ack-number for simplify. Ack-numebr is mainly used to response last received TCP message that your message I have received.</li><li>*<em>Header Length</em>: The length of TCP header, usually is 20 Bytes.</li><li><strong>Flag Bits</strong>:<ul><li><strong>URG=1</strong>: enable Uregent Pointer</li><li><strong>ACK=1</strong>: enable Acknowledgement Number </li><li><strong>PSH=1</strong>: This message should be submitted to application layer as soon as possible.</li><li><strong>RST=1</strong>: reset connection</li><li><strong>SYN=1</strong>: open a new connection</li><li><strong>FIN=1</strong>: finish a connection</li></ul></li><li><p><strong>CheckSum and Urgent Pinter</strong>:<br><strong>CheckSum</strong> is utilized to check correctness of TCP message to avoid the loss of data in transmission process. In TCP protocol, if transport find that the TCP package in error, it will request the Client/Server resend this package. Urgent pointer, I do not know the usage of this segment.</p></li><li><p><strong>Notes</strong>:</p><ul><li>Acknowledge Number(ack) and ACK flag are different things in TCP header.</li></ul></li></ul><h2 id="2-Three-Way-Handshake"><a href="#2-Three-Way-Handshake" class="headerlink" title="2. Three-Way Handshake"></a>2. Three-Way Handshake</h2><p>Three-Way Handshake refers to that the client and server link establish process requires three data package in total.This process is generally raised by client function <strong>connect()</strong>, and the mainly process of three way handshake is shown in the following picture.</p><p><img src="https://upload-images.jianshu.io/upload_images/13348038-fe57d097a914e27c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><strong>First-Way Handshake</strong>:<br>Client sets SYN bits as 1, that is SYN=1, and randomly generates a sequence value i, that is seq=i, and sends data package to server. After that client changes state to SYN-SENT and waits for the ackknowledgement of server. Meanwhile, server keeps LISTEN state until the data package come in.</li><li><strong>Second-Way Handshake</strong>:<br>Server receive the first package and check the SYN bit. When SYN=1, server knows that client suppose to establish connection with himself. Then the server responds an data package and sets ACK and SYN bit as 1. acknowledgement sequence assigns to i+1, that is ack=i+1, as a respose for first data package. Meanwhile, server also randomly produces a sequence j, that is seq=j, then this package would be send back. After that sever status is setted to SYN-RECV status.</li><li><strong>Three-Way Handshake</strong>:<br>When Client receives the package, it will check the acknowledgement sequence’s value and the ACK bit. If ACK=1 and seq=i+1, it will send the last package of the Three-Way Handshake. The ACK bit also is setted as 1 and the seq=j+1, then this package is sent to server by client. Once this package leaves away client, it state is setted as ESTAB-LISHED which represents that the TCP connection has been established successfully. Then, the client and server can tranfer datas each other.<h2 id="3-Four-Way-Wavehand"><a href="#3-Four-Way-Wavehand" class="headerlink" title="3. Four-Way Wavehand"></a>3. Four-Way Wavehand</h2>Four-Way Wavehand refers to that close a TCP connection require four package between client and server in total. The reson why close a TCP connection needs four package is that TCP connection is a Full Duplex data transfers channel. Thus, client and server must close respectively, called half-close, to avoid loss of data.</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13348038-20a6e02b754a085e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Duing to TCP connection is full duplex data transfers channel, each channel must be closed one by one to avoid loss of data. For example, when Client hasn’t data to transfrom, the client will send a package with FIN=1 to tell Server that I do not send any package, but I can receive package. After the server receives this package, it will response a package to tell client that I know you will not send package anymore, and keep sending package to client util data finish.</p><ul><li><strong>One-Way Wavehand</strong>:<br>Client sends a package with FIN=1, seq=i to colse the data send channel, and then Clinet change to FIN-WAIT1 state.</li><li><strong>One-Way Wavehand</strong>:<br>After Servre receives the package with FIN=1, it sends a package with ACK=1,seq=i+1 to acknowledge received package, then changes to CLOSE-WAIT state.</li><li><p><strong>One-Way Wavehand</strong>:<br>After Servre sends over it’s data, it will send a package with FIN=1, seq=j and changes it state to LAST-ACK.</p></li><li><p><strong>One-Way Wavehand</strong>:<br>The Client sends the last ACK package to Server, and changes t o TIME-WAIT state, which waits to 2MSL to avoid loss of package. Then Client is closed, and when the servre receive the last ACK package, it will be colsed to.</p></li><li><p><strong>Notes</strong>:</p><ul><li><strong>TIME-WAIT</strong>: MSL is the longest time of IP package exists in the internet. As result of routing abnormal, many packages always get loss in internet. And routing abnormal always requires several minute to fix it. During routing abnormal , package may get loss and loop in routes, meanwhile, transmitting end may resend this package, and the lossed package is called lost duplicate or wandering duplicate. TCP protocol must be able to deal wandering duplicate correctly. Therefore, TIME-WAIT state exist in TCP protocol is resonable. Firstly, Reliable implement of TCP full duplex protocol termination. Secondly, Allows duplicate segments to disappear in the network.<h2 id="4-Code-For-Linux"><a href="#4-Code-For-Linux" class="headerlink" title="4. Code For Linux"></a>4. Code For Linux</h2>There is the flow chart of TCP connection and linux code.</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13348038-ad7f7218e572285e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cs.jpg"></p><pre><code>//Client #include&lt;sys/socket.h&gt;#include&lt;time.h&gt;#define MAXLEN 1024int main(int argc,char** argv){    int sockfd;    struct sockaddr_in servaddr;    if(argc!=2)        err_quit(&quot;usage: tcpli &lt;IP address&gt;&quot;);    sockfd=socket(AF_INET,SOCK_STREAM,0);    bzero(&amp;servaddr,sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_port=htons(13);    inet_port(AF_INET,argv[1],&amp;Servaddr.sin_addr);    connect(sockfd,(SA*)&amp;Servaddr,sizeof(servaddr));    str_cli(stdin,sockfd);    return 0;}void str_cli(FILE *fp,int sockfd){    char sendline[MAXLEN],recvline[MAXLEN];    while(fgets(sendline,MAXLEN,fp)!=NULL){        write(sockfd,sendline,strlen(sendline));        if(readline(sockfd,recvline,MAXLEN)==0)            err_quit(&quot;str_cli:server terminated prematruely&quot;);        fputs(recvline,stdout);    }}//Server#include&lt;sys/socket.h&gt;int main(){    int listenfd,connfd;    pid_t child_pid;    socklen_t clilen;    struct sockaddr_in cliaddr,servaddr;    listenfd=socket(AF_INET,SOCK_STREAM,0);    bzero(&amp;servaddr,sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);    servaddr.sin_port=htons(13);    bind(listenfd,(SA*)&amp;servaddr,sizeof(servaddr));    listen(listenfd,LISTENQ);    for(;;){        clilen=sizeof(cliaddr);        connfd=accept(listenfd,(SA*)&amp;cliaddr,&amp;clilen);        if((chilpid=fork()==0)){            close(listenfd);            str_echo(connfd);            exit(0);        }        close(connfd);    }    return 0;}void str_echo(int sockfd){    ssize_t n;    char buf[MAXLEN];    again:        while((n=read(sockfd,buf,MAXLEN))&gt;0)            write(sockfd,buf,n);        if(n&lt;0&amp;&amp;errno=EINTR)            goto again;        else if(n&lt;0)            err_sys(&quot;str_echo: read error&quot;);}</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.cnblogs.com/Qing-840/p/9283367.html" target="_blank" rel="noopener">https://www.cnblogs.com/Qing-840/p/9283367.html</a></p><p>[2] &lt;&lt;TCP/IP Illustrated, Volume 1: The Protocols&gt;&gt;</p><p>[3] &lt;<UNIX network programming>&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-TCP-Header-Format&quot;&gt;&lt;a href=&quot;#1-TCP-Header-Format&quot; class=&quot;headerlink&quot; title=&quot;1. TCP Header Format&quot;&gt;&lt;/a&gt;1. TCP Header Format&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>SpinLock In Linux</title>
    <link href="http://yoursite.com/2020/05/15/SpinLock-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/SpinLock-In-Linux/</id>
    <published>2020-05-15T14:30:05.000Z</published>
    <updated>2020-05-15T14:30:28.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p><a href="#pthread_spinlock_t">pthread_spinlock_t</a></p><p><a href="#pthread_spin_init">pthread_spin_init</a></p><p><a href="#pthread_spin_destroy">pthread_spin_destroy</a></p><p><a href="#pthread_spin_lock">pthread_spin_lock</a></p><p><a href="#pthread_spin_trylock">pthread_spin_trylock</a></p><p><a href="#pthread_spin_unlock">pthread_spin_unlock</a><br><a href="#code">code</a></p><h2 id="pthread-spinlock-t"><a href="#pthread-spinlock-t" class="headerlink" title="pthread_spinlock_t"></a>pthread_spinlock_t</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes method</span></span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> spinlock;</span><br><span class="line">pthread_spin_init(&amp;spinlock,<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h2 id="pthread-spin-init"><a href="#pthread-spin-init" class="headerlink" title="pthread_spin_init"></a>pthread_spin_init</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock,<span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line">args:</span><br><span class="line">    -lock: the spinlock type in linux</span><br><span class="line">    -pshared: </span><br><span class="line">        -PTHREAD_PROCESS_PRIVATE:spinlock can only be operated by the threads in the same process.</span><br><span class="line">        -PTHREAD_PROCESS_SHARED:spinlock can be operated by any thread in any process.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: Exxx</span><br></pre></td></tr></table></figure><h2 id="pthread-spin-destroy"><a href="#pthread-spin-destroy" class="headerlink" title="pthread_spin_destroy"></a>pthread_spin_destroy</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line">args:</span><br><span class="line">   -lock: the spinlock type in linux</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">   successed: <span class="number">0</span></span><br><span class="line">   error: Exxx</span><br></pre></td></tr></table></figure><h2 id="pthread-spin-lock"><a href="#pthread-spin-lock" class="headerlink" title="pthread_spin_lock"></a>pthread_spin_lock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"> args:</span><br><span class="line">    -lock: the spinlock type in linux</span><br><span class="line"> <span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: Exxx</span><br></pre></td></tr></table></figure><h2 id="pthread-spin-trylock"><a href="#pthread-spin-trylock" class="headerlink" title="pthread_spin_trylock"></a>pthread_spin_trylock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"> args:</span></span><br><span class="line">    -lock: the spinlock type in linux</span><br><span class="line"> <span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: Exxx</span><br></pre></td></tr></table></figure><h2 id="pthread-spin-unlock"><a href="#pthread-spin-unlock" class="headerlink" title="pthread_spin_unlock"></a>pthread_spin_unlock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line">args:</span><br><span class="line">   -lock: the spinlock type in linux</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">   successed: <span class="number">0</span></span><br><span class="line">   error: Exxx</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><hr><ul><li><p><strong>producer and comsumer model 1: N-1</strong> In this model, we build a class, called CritialZone, where we have a pool to write and read (produce and consume). In this model, we simplely create 10 threads as producer to produce data. After pool is full, we call consumer to read all data in one time.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CriticalZone</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_spinlock_t</span> s_mutex;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s_pool;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_size;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_cur;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> CriticalZone::s_mutex;</span><br><span class="line"><span class="keyword">int</span> CriticalZone::s_size=<span class="number">1024</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; CriticalZone::s_pool;</span><br><span class="line"><span class="keyword">int</span> CriticalZone::s_cur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> CriticalZone::s_val=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;CriticalZone::s_size;++i)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consuming data: "</span>&lt;&lt;CriticalZone::s_pool[CriticalZone::s_cur]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        CriticalZone::s_cur--;</span><br><span class="line">        CriticalZone::s_pool.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        pthread_spin_lock(&amp;CriticalZone::s_mutex);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_"</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">" is writing value:"</span>&lt;&lt;CriticalZone::s_val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(CriticalZone::s_cur&gt;=CriticalZone::s_size)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"pool is full"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            pthread_spin_unlock(&amp;CriticalZone::s_mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CriticalZone::s_pool.push_back(CriticalZone::s_val);</span><br><span class="line">        CriticalZone::s_val++;</span><br><span class="line">        CriticalZone::s_cur++;</span><br><span class="line">        pthread_spin_unlock(&amp;CriticalZone::s_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">pthread_t</span>&gt; <span class="title">tids</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    pthread_spin_init(&amp;CriticalZone::s_mutex,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;tids[i],<span class="literal">nullptr</span>,producer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_join(tids[i],<span class="literal">nullptr</span>))&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,consumer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(tid,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main end!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>producer and consumer model 2: N-1</strong> In this model, we create 10 threads to write and one threads to read. When there is no data in the pool, the consumer should recurrently wait for the data, util the pool is not empty.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CriticalZone</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_spinlock_t</span> s_mutex;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s_pool;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_size;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_cur;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> CriticalZone::s_mutex;</span><br><span class="line"><span class="keyword">int</span> CriticalZone::s_size=<span class="number">1024</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; CriticalZone::s_pool;</span><br><span class="line"><span class="keyword">int</span> CriticalZone::s_cur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> CriticalZone::s_val=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_wait</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        pthread_spin_lock(&amp;CriticalZone::s_mutex);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;CriticalZone::s_cur)&#123;</span><br><span class="line">            pthread_spin_unlock(&amp;CriticalZone::s_mutex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_spin_unlock(&amp;CriticalZone::s_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;CriticalZone::s_size;++i)&#123;</span><br><span class="line">        consume_wait(i);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consuming data: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        pthread_spin_lock(&amp;CriticalZone::s_mutex);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_"</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">" is writing value:"</span>&lt;&lt;CriticalZone::s_val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(CriticalZone::s_cur&gt;=CriticalZone::s_size)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"pool is full"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            pthread_spin_unlock(&amp;CriticalZone::s_mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CriticalZone::s_pool.push_back(CriticalZone::s_val);</span><br><span class="line">        CriticalZone::s_val++;</span><br><span class="line">        CriticalZone::s_cur++;</span><br><span class="line">        pthread_spin_unlock(&amp;CriticalZone::s_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">pthread_t</span>&gt; <span class="title">tids</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    pthread_spin_init(&amp;CriticalZone::s_mutex,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;tids[i],<span class="literal">nullptr</span>,producer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,consumer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_join(tids[i],<span class="literal">nullptr</span>))&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(tid,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main end!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>producer and consumer model 3: N-N</strong> In this model, we create 10 threads to write and 10 threads to read. when and only when, there are on writers or readers writing or reading writer and reader can write and read. That is to say, lock is monopolized by one object.<pre><code class="cc"></code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;header&quot;&gt;&lt;a href=&quot;#header&quot; class=&quot;headerlink&quot; title=&quot;header&quot;&gt;&lt;/a&gt;header&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Fiber In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Fiber-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Fiber-In-Linux/</id>
    <published>2020-05-15T14:29:20.000Z</published>
    <updated>2020-05-15T14:29:42.346Z</updated>
    
    <content type="html"><![CDATA[<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p><p>Coroutines are very similar to threads. However, coroutines are cooperatively multitasked, whereas threads are typically preemptively multitasked. This means that coroutines provide concurrency but not parallelism. The advantages of coroutines over threads are that they may be used in a hard-realtime context (switching between coroutines need not involve any system calls or any blocking calls whatsoever), there is no need for synchronisation primitives such as mutexes, semaphores, etc. in order to guard critical sections, and there is no need for support from the operating system.</p><p>It is possible to implement coroutines using preemptively-scheduled threads, in a way that will be transparent to the calling code, but some of the advantages (particularly the suitability for hard-realtime operation and relative cheapness of switching between them) will be lost [1].</p><p>In this blog, we will introduce the Linux library “ucontext.h” and use it to implement a simple coroutines program.</p><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><hr><ul><li><a href="#ucontext_t">ucontext_t</a></li></ul><!--[mcontext_t](#mcontext_t)--><ul><li><p><a href="#getcontext">getcontext</a></p></li><li><p><a href="#setcontext">setcontext</a></p></li><li><p><a href="#makecontext">makcontext</a></p></li><li><p><a href="#swapcontext">swapcontext</a></p></li><li><a href="#code">code</a></li></ul><h2 id="ucontext-t"><a href="#ucontext-t" class="headerlink" title="ucontext_t"></a>ucontext_t</h2><hr><p>The  mcontext_t  type  is  machine-dependent and opaque.  The<br>ucontext_t type is a structure that has at least the following fields:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></span><br><span class="line">            <span class="comment">//points to the context that will be resumed  when  thecurrent  context  terminates</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span>  </span><br><span class="line">           <span class="comment">// the set of  signals  blocked  in this context</span></span><br><span class="line">           <span class="keyword">sigset_t</span>          uc_sigmask;</span><br><span class="line">           <span class="comment">//the stack used by this context</span></span><br><span class="line">           <span class="keyword">stack_t</span>           uc_stack;</span><br><span class="line">           <span class="comment">//the  machine-specific  representation of the saved context, that includes  the  calling  thread machine registers.</span></span><br><span class="line">           <span class="keyword">mcontext_t</span>        uc_mcontext;</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure></p><h2 id="getcontext"><a href="#getcontext" class="headerlink" title="getcontext"></a>getcontext</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get the user context</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">   -ucp: the <span class="keyword">ucontext_t</span> type, points to the context.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">   seccessed: <span class="number">0</span></span><br><span class="line">   error: <span class="number">-1</span> <span class="keyword">and</span> <span class="built_in">set</span> errno appropriately.</span><br></pre></td></tr></table></figure><h2 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set the user context</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">   -ucp: the <span class="keyword">ucontext_t</span> type, points to the context.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">   seccessed: does <span class="keyword">not</span> <span class="keyword">return</span>.</span><br><span class="line">   error: <span class="number">-1</span> <span class="keyword">and</span> <span class="built_in">set</span> errno appropriately.</span><br></pre></td></tr></table></figure><h2 id="makecontext"><a href="#makecontext" class="headerlink" title="makecontext"></a>makecontext</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modifies the context pointed to by ucp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, <span class="keyword">void</span> (*func)(), <span class="keyword">int</span> argc, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -ucp: the context pointer.</span><br><span class="line">    -func: When <span class="keyword">this</span> context is later activated the function func is called, </span><br><span class="line">    -argc: passed the  series  of  integer arguments  that  follow  argc to func; the caller must specify the number of these arguments in argc .</span><br><span class="line"><span class="keyword">return</span>: </span><br><span class="line">    no</span><br></pre></td></tr></table></figure><h2 id="swapcontext"><a href="#swapcontext" class="headerlink" title="swapcontext"></a>swapcontext</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//saves the current context in the structure pointed to by oucp, and then activates the context pointed to by ucp.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -oucp: The swapcontext() function saves the current context in the structure pointed to by oucp.</span><br><span class="line">    -ucp:  the context pointer.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: does <span class="keyword">not</span> <span class="keyword">return</span>, (But we may <span class="keyword">return</span> later, in <span class="keyword">case</span> oucp is activated, in which <span class="keyword">case</span>  it  looks  like  swapcontext() returns <span class="number">0.</span>)</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> sets errno appropriately.</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><hr><p>In this program, we use getcontext() to get the context before print “hello world”, then we use setcontext() to recover the context which we stored. Therefore, this program print “hello world” recurrently.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using getcontext and setcontext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">ucontext_t</span> context;</span><br><span class="line"></span><br><span class="line">        getcontext(&amp;context);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        setcontext(&amp;context);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>result:<br><img src="https://upload-images.jianshu.io/upload_images/13348038-76df75111b70b830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Coroutine#Comparison_with_threads" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Coroutine#Comparison_with_threads</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspe
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>RWLock In Linux</title>
    <link href="http://yoursite.com/2020/05/15/RWLock-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/RWLock-In-Linux/</id>
    <published>2020-05-15T14:28:33.000Z</published>
    <updated>2020-05-15T14:28:53.244Z</updated>
    
    <content type="html"><![CDATA[<p>Mutex Lock blocks all the threads which attempts to enter critical section. However, the enter cirtical section operation can be divided into read data and write data. According to this principle, the lock can be separted as read lock and write lock. The read-write lock requires to obey the following rules:</p><ul><li>as long as no thread holds any write lock, any threads can get any type (read or write) lock to read.</li><li>when and only when no lock is used to write or read, write lock can be allocated and used to write.</li></ul><p>That is to say, as long as no thread is modifing critical section, any type lock can be used to read. When and only when on any other threads are modifing critical section, write lock is able to write.</p><h1 id="header"><a href="#header" class="headerlink" title="header"></a>header</h1><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><p><a href="#pthread_rwlock_t">pthread_rwlock_t</a></p><p><a href="#pthread_rwlock_rdlock">pthread_rwlock_rdlock</a></p><p><a href="#pthread_rwlock_wrlock">pthread_rwlock_wrlock</a></p><p><a href="#pthread_rwlock_unlock">pthread_rwlock_unlock</a></p><p><a href="#pthread_rwlock_trywrlock">pthread_rwlock_tryrdlock</a></p><p><a href="#pthread_rwlock_trywrlock">pthread_rwlock_trywrlock</a></p><p><a href="pthread_rwlock_destroy">pthread_rwlock_destroy</a></p><p><a href="#pthread_rwlockattr_init">pthread_rwlockattr_init</a></p><p><a href="pthread_rwlockattr_destroy">pthread_rwlockattr_destroy</a></p><p><a href="pthread_rwlockattr_getpshared">pthread_rwlockattr_getpshared</a></p><p><a href="pthread_rwlockattr_setpshared">pthread_rwlockattr_setpshared</a></p><h2 id="pthread-rwlock-t"><a href="#pthread-rwlock-t" class="headerlink" title="pthread_rwlock_t"></a>pthread_rwlock_t</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The defination of pthread_rwlock_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> rw_mutex;   <span class="comment">/*basic lock on this struct*/</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> rw_condreaders;  <span class="comment">/*for reader threads waiting*/</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> rw_condwriters;  <span class="comment">/*for writer threads waiting*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_magic;   <span class="comment">/*for error checking*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_nwaitreaders;    <span class="comment">/*the number waiting*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_nwaitwriters;    <span class="comment">/*the number waiting*/</span></span><br><span class="line">    <span class="keyword">int</span> rw_refcount;    <span class="comment">/*-1 if writer has the lock, else readers holding the lock*/</span></span><br><span class="line">&#125;<span class="keyword">pthread_rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_RWLOCK_INITIALIZER&#123;</span></span><br><span class="line">    PTHREAD_LOCK_INITIALIZER,</span><br><span class="line">    PTHREAD_COND_INITIALIZER,</span><br><span class="line">    PTHREAD_COND_INITIALIZER,</span><br><span class="line">    RW_MAGIC,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get a read lock, if the lock hold by other thread, blocking and waiting for unlocking.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-wrlock"><a href="#pthread-rwlock-wrlock" class="headerlink" title="pthread_rwlock_wrlock"></a>pthread_rwlock_wrlock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get a write lock, if lock is got by other threads, blocking and waiting for unlocking.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a>pthread_rwlock_unlock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//release a read-wirte lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-tryrdlock"><a href="#pthread-rwlock-tryrdlock" class="headerlink" title="pthread_rwlock_tryrdlock"></a>pthread_rwlock_tryrdlock</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gets a read lock, if the lock hold by other thread, return a EXXX without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-trywrite"><a href="#pthread-rwlock-trywrite" class="headerlink" title="pthread_rwlock_trywrite"></a>pthread_rwlock_trywrite</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gets a write lock, if the lock hold by other thread, return a EXXX without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes a read-write lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr,<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line">    -attr: the attribute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//destroy a read-write lock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -rwptr: the read-write lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlockattr-init"><a href="#pthread-rwlockattr-init" class="headerlink" title="pthread_rwlockattr_init"></a>pthread_rwlockattr_init</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set a pthread_rwlockattr_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlockattr-destroy"><a href="#pthread-rwlockattr-destroy" class="headerlink" title="pthread_rwlockattr_destroy"></a>pthread_rwlockattr_destroy</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//destroy a pthread_rwlockattr_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlockattr-getpshared"><a href="#pthread-rwlockattr-getpshared" class="headerlink" title="pthread_rwlockattr_getpshared"></a>pthread_rwlockattr_getpshared</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr,<span class="keyword">int</span> *valptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line">    -valptr: the attribute value</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="pthread-rwlockattr-setpshared"><a href="#pthread-rwlockattr-setpshared" class="headerlink" title="pthread_rwlockattr_setpshared"></a>pthread_rwlockattr_setpshared</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *attr,<span class="keyword">int</span> *valptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -attr: the attribute</span><br><span class="line">    -valptr: the attribute value</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    seccessed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mutex Lock blocks all the threads which attempts to enter critical section. However, the enter cirtical section operation can be divided 
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mutex In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Mutex-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Mutex-In-Linux/</id>
    <published>2020-05-15T14:27:58.000Z</published>
    <updated>2020-05-15T14:28:17.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;thread.h&gt;</span><br></pre></td></tr></table></figure><h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><hr><p><a href="#pthread_mutex_t">pthread_mutex_t</a></p><p><a href="#pthread_mutex_lock">pthread_mutex_lock</a></p><p><a href="#pthread_mutex_trylock">pthread_mutex_trylock</a></p><p><a href="pthread_mutex_init">pthread_muext_init</a></p><p><a href="#pthread_mutex_unlock">pthread_mutex_unlock</a></p><p><a href="#pthread_mutex_destroy">pthread_mutex_destroy</a></p><h2 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h2><p>The pthread_mutex_t is a mutex data type, which can be initialized by two methods.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if pthread_mutex_t is declared as a static variable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock=PTHREAD_MUTEX_INITILIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if pthread_mutex_t is declared as a dynamic variable</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span>* lock;</span><br><span class="line">pthread_mutex_init(lock);</span><br></pre></td></tr></table></figure></p><h2 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h2><p>Try to lock a mutex, if the mutex is locked, blocking and waiting for until it is unlock.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lock a mutex variable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mptr: a pointer of mutex.</span><br><span class="line"><span class="keyword">return</span>: </span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure></p><h2 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock"></a>pthread_mutex_trylock</h2><p>Try to lock a mutex, if it is locked, return a EBUSY.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mptr: a pointer of mutex.</span><br><span class="line"><span class="keyword">return</span>: </span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure></p><h2 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h2><p>unlock a mutex, if it is unlock, blocking and waitting.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mptr: a pointer of mutex</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure></p><h2 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy"></a>pthread_mutex_destroy</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mutex: the mutex type</span><br><span class="line">    -attr: attribute of mutex</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: Exxx</span><br></pre></td></tr></table></figure><h2 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    -mutex: the mutex type</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: <span class="number">0</span></span><br><span class="line">    error: EXXX</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//consumer and producer model</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> nmax;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> ncur;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> nval;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> Shared::lock=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Shared::<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">int</span> Shared::nmax=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Shared::ncur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Shared::nval=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;Shared::lock);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread ["</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">"] is writing value: "</span>&lt;&lt;Shared::nval&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(Shared::ncur&gt;=Shared::nmax)&#123;</span><br><span class="line">                        pthread_mutex_unlock(&amp;Shared::lock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Shared::<span class="built_in">array</span>.push_back(Shared::nval);</span><br><span class="line">                Shared::ncur++;</span><br><span class="line">                Shared::nval++;</span><br><span class="line">                pthread_mutex_unlock(&amp;Shared::lock);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Shared::<span class="built_in">array</span>.size();++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consume value: "</span>&lt;&lt;Shared::<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc!=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"arguments number error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nmax=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> nthreads=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">pthread_t</span>&gt; <span class="title">producer_tids</span><span class="params">(nthreads)</span></span>;</span><br><span class="line">        <span class="keyword">pthread_t</span> consumer_tid;</span><br><span class="line">        Shared::nmax=nmax;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nthreads;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pthread_create(&amp;producer_tids[i],<span class="literal">nullptr</span>,producer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nthreads;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pthread_join(producer_tids[i],<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_join error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread "</span>&lt;&lt;i&lt;&lt;<span class="string">" Done!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;consumer_tid,<span class="literal">nullptr</span>,consumer,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pthread_join(consumer_tid,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_join error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main Function Done!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;header&quot;&gt;&lt;a href=&quot;#header&quot; class=&quot;headerlink&quot; title=&quot;header&quot;&gt;&lt;/a&gt;header&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Thread In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Thread-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Thread-In-Linux/</id>
    <published>2020-05-15T14:27:20.000Z</published>
    <updated>2020-05-15T14:27:44.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><hr><ul><li><a href="#pthread_create">pthread_create</a>()</li><li><a href="#pthread_join">pthread_join</a>()</li><li><a href="#pthread_detach">pthread_detach</a>()</li><li><a href="#pthread_self">pthread_slef</a>()</li><li><a href="#pthread_exit">pthread_exit</a>()</li></ul><h2 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void* (*start_routine)(void*), void *arg);</span><br></pre></td></tr></table></figure><ul><li><strong>brief:</strong> The pthread_create() function starts a new thread in the calling process, the new thread starts execution by invoking start_routine();</li><li><p><strong>arguments:</strong></p><ul><li><strong>-thread:</strong> The pointer points to thread identifier.</li><li><strong>-attr:</strong> The  attr argument points to a pthread_attr_t structure whose contents are used at thread creation time to determine attributes for the new thread;this structure is initialized using pthread_attr_init(3) and related functions.  If  attr  is  NULL,  then  the  thread  is  created  with  default attributes.</li><li><strong>-start_routine:</strong> The function address of thread run.</li><li><strong>-arg</strong> The arguments of start_toutine.</li></ul></li><li><p><strong>return value:</strong><br>On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined.</p></li><li><strong>Code:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread&gt;</span></span></span><br><span class="line"><span class="comment">//this is a sample example of pthread_create.</span></span><br><span class="line"><span class="comment">//start routine 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_1: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//start routine2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func2</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_2: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp1;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp2;</span><br><span class="line">    <span class="comment">//using pthread_create creates a function</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tidp1,<span class="literal">nullptr</span>,func1,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//using pthread_create creates a function</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tidp2,<span class="literal">nullptr</span>,func2,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_main: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>Note:</strong> The library “pthread.h” is not a build in library of linux, when you compile source code, you should add commain <strong>-lpthread</strong> like this:<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ thread_create.cc -lpthread</span><br></pre></td></tr></table></figure><h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h2></li></ul><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span>** retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>brief:</strong> The pthread_join() function waits for the thread specified by thread to terminate, If that thread has already terminated, then pthread_join run immediately.The thread specified by thread must be joinable.</p></li><li><p><strong>arguments:</strong> </p><ul><li><strong>-thread:</strong> The thread identifier that is waitted.</li><li><strong>-retval:</strong>  The return value of thread which is waitted</li></ul></li><li><p><strong>return value</strong> On success, pthread_join() returns 0; on error, it returns an error number.</p></li><li><p><strong>Note:</strong> This function is a blocking funtion. Suppose we have two thread, thread A and thread B. If we call pthread_join() int thread A, thread A will blocking wait for the finish of thread B. If we do not call pthread_join, thread A may finish quickly, and thread B can not be executed.</p></li><li><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//In this program, we do not call pthread_join(), the main </span></span><br><span class="line"><span class="comment">//function finished before thread_1 fininshed.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_1: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,func1,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_main: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main Function END!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Result:<br><img src="https://upload-images.jianshu.io/upload_images/13348038-c5c6cfe7efe3895a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//The pthread_join() is called, the main thread waits for //thread 1 finish.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_1: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,func1,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread_main: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pthread_join(tid,<span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main Function END!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13348038-4fd12eaa3611cca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h2><hr><p><a href="https://note.youdao.com/" target="_blank" rel="noopener">link</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_detach(pthread_t thread);</span><br></pre></td></tr></table></figure></p><ul><li><strong>Brief:</strong> The pthread_detach()  function  marks the thread identified by thread as detached.  When a detached thread terminates, its resources are automati‐cally released back to the system without the need for another thread to join with the terminated thread.Attempting to detach an already detached thread results in unspecified behavior.</li><li><strong>Arguments:</strong><ul><li><strong>-thread:</strong> The detached thread identifier.</li></ul></li><li><p><strong>Return Value:</strong><br>On success, pthread_detach() returns 0; on error, it returns an error number.</p></li><li><p><strong>Code:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">&#x2F;&#x2F;The func is a dead loop, but the resources of pthread_detach() </span><br><span class="line">&#x2F;&#x2F;marks program are automatically released back to system. So </span><br><span class="line">&#x2F;&#x2F;the loop finished after Main process is finished.</span><br><span class="line">void* func(void* arg)&#123;</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">                std::cout&lt;&lt;&quot;thread_1 running ...&quot;&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pthread_t tid;</span><br><span class="line">        if(pthread_create(&amp;tid,nullptr,func,nullptr)&#x3D;&#x3D;-1)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_detach(tid);</span><br><span class="line">        std::cout&lt;&lt;&quot;Main Function Done!&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13348038-92c4f0747486ddab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_t pthread_self(void);</span><br></pre></td></tr></table></figure><ul><li><strong>Brief:</strong> The pthread_self() function returns the ID of the calling thread.  This is the same value that is returned in *thread in the pthread_create(3) call that created this thread.</li><li><strong>Return:</strong><br>This function always succeeds, returning the calling thread’s ID.</li><li><strong>Code:</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* func(void* arg)&#123;</span><br><span class="line">        pthread_detach(pthread_self());</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">                std::cout&lt;&lt;&quot;thread 1 running ...\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pthread_t tid;</span><br><span class="line">        if(pthread_create(&amp;tid,nullptr,func,nullptr))&#123;</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;&quot;Main Function Done!&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void pthread_exit(void* retval);</span><br></pre></td></tr></table></figure></li><li><p><strong>Brief:</strong></p><p>  The  pthread_exit()  function terminates the calling thread and returns a value via retval that (if the thread is joinable) is available to another<br>  thread in the same process that calls pthread_join(3).</p><p>  Any clean-up handlers established by pthread_cleanup_push(3) that have not yet been popped, are popped (in the reverse of the order in  which  they<br>  were  pushed)  and  executed.   If the thread has any thread-specific data, then, after the clean-up handlers have been executed, the corresponding<br>  destructor functions are called, in an unspecified order.</p><p>  When a thread terminates, process-shared resources (e.g., mutexes, condition variables, semaphores, and file descriptors)  are  not  released,  and<br>  functions registered using atexit(3) are not called.</p><p>  After  the  last  thread  in  a  process terminates, the process terminates as by calling exit(3) with an exit status of zero; thus, process-shared<br>  resources are released and functions registered using atexit(3) are called.</p></li><li><strong>Arguments:</strong><ul><li><strong>-retval:</strong> void* pointer, I do not know the mean of this argument.</li></ul></li><li><strong>Code:</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void* func(void* arg)&#123;</span><br><span class="line">        pthread_detach(pthread_self());</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">                std::cout&lt;&lt;&quot;thread 1 running ...\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pthread_t tid;</span><br><span class="line">        if(pthread_create(&amp;tid,nullptr,func,nullptr))&#123;</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;&quot;Main Function Done!&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Pipe In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Pipe-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Pipe-In-Linux/</id>
    <published>2020-05-15T14:26:33.000Z</published>
    <updated>2020-05-15T14:26:53.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;uinstd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><ul><li><a href="#conception">conception</a></li><li><a href="#pipe">pipe</a></li><li><a href="#pipe2">pipe2</a></li><li><a href="#code">code</a></li></ul><h2 id="conception"><a href="#conception" class="headerlink" title="conception"></a>conception</h2><hr><p>Pipe is one of the most basic IPC machanism in Linux system, whihc is able to tranfer data in parent and child process. We can easily creat and use pipe by Linux system call. The size of pipe is <strong>65KB</strong> in generally.</p><p><strong>The attributes of pipe includes:</strong></p><ol><li>The pipe is a file in logical. Actually, it is a Linux kernel buffer.</li><li>There are two file descriptor in a pipe, and they respectively represents write and read.</li><li>The data must enter pipe by write end, and leave pip by read end.<br>In a word, pipe is a circle queue mechanism which is used by linux kernel.</li></ol><p><strong>The limitaion of pipe:</strong></p><ol><li>Once the data is readed, the data are taken forever, and the pipe dosen’t reserve those data.</li><li>The pipe is a half word channel, which can only be read in one side.</li><li>The pipe can only be accessed by the processes which has the same father process or with father process.</li></ol><p><strong>The process of parent thread and child thread IPC</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/13348038-361488176f58b439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>The father process calls pipe function to cerate an pipe, which obtains fd[0] and fd[1].</li><li>The father process fork() an child process, both father and child process have fd[0] and fd[0].</li><li>The father process colses the read end and child process colse the write end. Then, the father process sends message to the pipe and the child process gets the data from pipe.</li></ol><p><strong>Four special situations about pipes</strong><br><img src="https://upload-images.jianshu.io/upload_images/13348038-9789f7955152bb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>If write side has no writers (write side file descriptor = 0), after data read over, the read file descriptor will return zero.</li><li><p>If write side has writers (write size file descriptor  &gt; 0), after pipe is empty, the reader will wait for the writer to write.<br><img src="https://upload-images.jianshu.io/upload_images/13348038-d58d65ba47340439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>If read side has no readers (read side file descriptor = 0), when writer try to write datas to the pipe, the process will receive SIGPIPE.</p></li><li>If read side has readers (read side file descriptor &gt; 0), when pipe is full, the writer will block and wait.</li></ol><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;create a pipe</span><br><span class="line">int pipe(int pipefd[2]);</span><br><span class="line"></span><br><span class="line">args</span><br><span class="line">    - pipefd: two file descriptor</span><br><span class="line">return</span><br><span class="line">    - success: 0</span><br><span class="line">    - error: -1</span><br><span class="line">    </span><br><span class="line">Notes:</span><br><span class="line">    - pipefd[0]: read</span><br><span class="line">    - pipefd[1]: write</span><br></pre></td></tr></table></figure><h2 id="pipe2"><a href="#pipe2" class="headerlink" title="pipe2"></a>pipe2</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If flags is 0, then pipe2() is the same as pipe().</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe2</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">args:</span><br><span class="line">    - pipefd: The file descriptor of pipe.</span><br><span class="line">    - flags:</span><br><span class="line">        - O_CLOEXEC:</span><br><span class="line">        - O_DIRECT</span><br><span class="line">        - O_NONBLOCK</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    - successed: <span class="number">0</span></span><br><span class="line">    - error: <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>An example of pipe, we fork a child process in the main process, the main process write data to the pipe and the child process read the data and print it to the console.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(fd)==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span>* p=<span class="string">"test of pipe\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">//child process</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>((len=read(fd[<span class="number">0</span>],buff,<span class="keyword">sizeof</span>(buff)))==<span class="number">-1</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(write(STDOUT_FILENO,buff,len)==<span class="number">-1</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//main process</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(write(fd[<span class="number">1</span>],p,<span class="built_in">strlen</span>(p))==<span class="number">-1</span>)&#123;</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">         <span class="keyword">char</span>* s=<span class="string">"main end!\n"</span>;</span><br><span class="line">         write(STDOUT_FILENO,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Semaphore-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Semaphore-In-Linux/</id>
    <published>2020-05-15T14:25:51.000Z</published>
    <updated>2020-05-15T14:26:18.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><hr><p><a href="#sem_t">sem_t</a></p><p><a href="#sem_init">sem_init</a></p><p><a href="#sem_open">sem_open</a></p><p><a href="#sem_destroy">sem_destroy</a></p><p><a href="#sem_wait">sem_wait</a></p><p><a href="#sem_post">sem_post</a></p><p><a href="#code">code</a></p><h2 id="sem-t"><a href="#sem-t" class="headerlink" title="sem_t"></a>sem_t</h2><hr><p>In C language, the sem_t is the semphore structor, which is a long int in basic.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef long long sem_t;</span><br></pre></td></tr></table></figure></p><h2 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br></pre></td></tr></table></figure><ul><li><strong>brief:</strong>  initializes the unnamed semaphore at the address pointed to by sem.  The value argument specifies the initial value for the semaphore.</li><li><p><strong>arguments:</strong></p><ul><li><strong>-sem:</strong> The semaphore flag.</li><li><p><strong>-pshared:</strong> indicates whether this semaphore is to be shared between the threads of a process, or between processes.<br>If pshared has the value 0, then the semaphore is shared between the threads of a process, and should be located at some address that is visible to<br> all threads (e.g., a global variable, or a variable allocated dynamically on the heap).</p><p> If pshared is nonzero, then the semaphore is shared between processes, and should be located  in  a  region  of  shared  memory  (see  shm_open(3),<br> mmap(2),  and shmget(2)).  (Since a child created by fork(2) inherits its parent’s memory mappings, it can also access the semaphore.)  Any process<br> that can access the shared memory region can operate on the semaphore using sem_post(3), sem_wait(3), and so on.</p><p> Initializing a semaphore that has already been initialized results in undefined behavior.</p></li><li><strong>-value:</strong> </li></ul></li><li><strong>return value:</strong><br>sem_init() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.</li><li><strong>code:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes unamed semaphore</span></span><br><span class="line"><span class="keyword">sem_t</span> *mutex;</span><br><span class="line">sem_init(mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="sem-open"><a href="#sem-open" class="headerlink" title="sem_open"></a>sem_open</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sem_t *sem_open(const char *name, int oflag);</span><br><span class="line">sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);</span><br></pre></td></tr></table></figure><ul><li><strong>brief:</strong>  initialize and open a named semaphore</li><li><p><strong>arguments:</strong> </p><ul><li><strong>-name:</strong> name of semphore.</li><li><p><strong>-flag:</strong> specifies flags that control the operation of the call. (Definitions  of  the  flags  values  can  be  obtained  by  including<br> &lt;fcntl.h&gt;.)  If O_CREAT is specified in oflag, then the semaphore is created if it does not already exist.  The owner (user ID) of the semaphore is<br> set to the effective user ID of the calling process.  The group ownership (group ID) is set to the effective group ID of the calling  process.   If<br> both O_CREAT and O_EXCL are specified in oflag, then an error is returned if a semaphore with the given name already exists.</p><p> If  O_CREAT is specified in oflag, then two additional arguments must be supplied.  The mode argument specifies the permissions to be placed on the<br> new semaphore, as for open(2).  (Symbolic definitions for the permissions bits can be obtained by including &lt;sys/stat.h&gt;.)   The  permissions  set‐<br> tings are masked against the process umask.  Both read and write permission should be granted to each class of user that will access the semaphore.<br> The value argument specifies the initial value for the new semaphore.  If O_CREAT is specified, and a semaphore with the given name already exists,<br> then mode and value are ignored.</p></li></ul></li><li><strong>return value:</strong>  On  success,  sem_open()  returns the address of the new semaphore; this address is used when calling other semaphore-related functions.  On error,<pre><code>sem_open() returns SEM_FAILED, with errno set to indicate the error.</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializes a named semaphore</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br><span class="line">mutex=sem_open(<span class="string">"name_mutex"</span>,O_CREATE,<span class="number">0644</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="sem-desroy"><a href="#sem-desroy" class="headerlink" title="sem_desroy"></a>sem_desroy</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> int sem_destroy(sem_t *sem);</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><ul><li><strong>brief:</strong> destroy an unnamed semaphore, sem_destroy() destroys the unnamed semaphore at the address pointed to by sem. Only a semaphore that has been initialized by sem_init(3) should be destroyed using sem_destroy().Destroying a semaphore that other processes or threads are currently blocked on (in sem_wait(3)) produces undefined behavior.Using a semaphore that has been destroyed produces undefined results, until the semaphore has been reinitialized using sem_init(3).</li><li><strong>arguments:</strong> <ul><li><strong>-sem:</strong> the semaphore ID.</li></ul></li><li><strong>return value:</strong> sem_destroy() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.</li><li><strong>code</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;initializes a semaphore and destory it.</span><br><span class="line">sem_t* mutex;</span><br><span class="line">sem_init(mutex,0,1);</span><br><span class="line">sem_desotroy(mutex);</span><br></pre></td></tr></table></figure></li></ul><h2 id="sem-wait-sem-trywait-sem-timewait"><a href="#sem-wait-sem-trywait-sem-timewait" class="headerlink" title="sem_wait, sem_trywait, sem_timewait"></a>sem_wait, sem_trywait, sem_timewait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;blocking lock a semaphore</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">args: </span><br><span class="line">    -sem: the semaphore ID.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;unblocking lock a semaphore</span><br><span class="line">int sem_trywait(sem_t *sem);</span><br><span class="line">args:</span><br><span class="line">    -sem: the semaphore ID</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="line">args:</span><br><span class="line">    -sem: the semaphore ID</span><br></pre></td></tr></table></figure><ul><li><p><strong>brief:</strong> </p><ul><li><p><strong>sem_wait()</strong> decrements (locks) the semaphore pointed to by sem.  If the semaphore’s value is greater than zero, then the decrement proceeds, and thefunction returns, immediately.  If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.</p></li><li><p><strong>sem_trywait()</strong>  is  the  same  as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking.</p></li><li><p><strong>sem_timedwait()</strong> is the same as sem_wait(), except that abs_timeout specifies a limit on the amount of time that the call should block if the decre‐ment cannot be immediately performed.  If the operation can be performed immediately, then sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout.  Fur‐thermore, the validity of abs_timeout is not checked in this case.</p></li></ul></li><li><p><strong>return value:</strong>   All of these functions return 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is  set  to  indicate the error.</p></li><li><strong>code:</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//place holder</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;increments (unlock) a semaphore</span><br><span class="line">int sem_post(sem_t *sem);</span><br><span class="line">args:</span><br><span class="line">    -sem: the semaphore ID</span><br></pre></td></tr></table></figure><ul><li><p><strong>brief:</strong>  sem_post()  increments  (unlocks)  the  semaphore pointed to by sem.  If the semaphore’s value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore.</p></li><li><p><strong>return value:</strong>  sem_post() returns 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.</p></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>There is my own simple semaphore class , which based on semaphore in linux. There are three files in total: semaphore.h, semaphore.cc and semaphore_test<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BEE_MUTEX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BEE_MUTEX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"macro.h"</span></span></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> *Class Semaphore</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Semaphore(<span class="keyword">int</span> count=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ~Semaphore();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trywait</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//The semaphore</span></span><br><span class="line">    <span class="keyword">sem_t</span> m_semaphore;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mutex.h"</span></span></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> *Class Semaphore</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line">Semaphore::Semaphore(<span class="keyword">int</span> count)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;m_semaphore,<span class="number">0</span>,count)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_init error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::~Semaphore()&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_destroy(&amp;m_semaphore)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_destroy error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::wait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;m_semaphore)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_wait error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::trywait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_trywait(&amp;m_semaphore)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_trywait error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_post(&amp;m_semaphore))&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"sem_post error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>And There is a test program of my Semaphore class, where we use semaphore to make  main thread thread 1 run a function func(). We set a global semaphore instance sem, and initializes it’s semaphore as 1. When main function or thread 1 are going to run, they must get a semaphore. Therefore, the program would be alternately executed in turn.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"../net/mutex.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bee;</span><br><span class="line"><span class="function"><span class="keyword">static</span> bee::Semaphore <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem.wait();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"func is running ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        sem.notify();</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,<span class="literal">nullptr</span>,func,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        sem.wait();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"main is running ..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        sem.notify();</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(tid,<span class="literal">nullptr</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>result:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br><span class="line">main is running ...</span><br><span class="line">func is running ...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;header&quot;&gt;&lt;a href=&quot;#header&quot; class=&quot;headerlink&quot; title=&quot;header&quot;&gt;&lt;/a&gt;header&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Basic IO In Linux</title>
    <link href="http://yoursite.com/2020/05/15/Basic-IO-In-Linux/"/>
    <id>http://yoursite.com/2020/05/15/Basic-IO-In-Linux/</id>
    <published>2020-05-15T14:24:34.000Z</published>
    <updated>2020-05-15T14:25:27.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="File-IO"><a href="#File-IO" class="headerlink" title="File IO"></a>File IO</h1><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcnt.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><hr><p><a href="#open">open</a></p><p><a href="#creat">creat</a></p><p><a href="#close">close</a></p><p><a href="#lseek">lseek</a></p><p><a href="#read">read</a></p><p><a href="#write">write</a></p><p><a href="#code">code</a></p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Opens a file and return it's file descriptor</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">int</span> oflag,...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">args:</span></span><br><span class="line">    - pathname: file path name</span><br><span class="line">    - oflag:</span><br><span class="line">        - O_RDONLY: read only</span><br><span class="line">        - O_WRONLY: write only</span><br><span class="line">        - RDWR: write <span class="keyword">and</span> read</span><br><span class="line">        - O_APPEND: appends to file end</span><br><span class="line">        - O_CREAT: <span class="keyword">if</span> file <span class="keyword">not</span> exist, creates a <span class="keyword">new</span> one</span><br><span class="line">        - O_EXCL: Test wether a file exist <span class="keyword">or</span> <span class="keyword">not</span>, <span class="keyword">if</span> <span class="keyword">not</span> atomaicly creates a file</span><br><span class="line">        - O_TRUNC: I dont know</span><br><span class="line">        - O_NOCTTY: I dont know</span><br><span class="line">        - O_NONBLOCK: If ptahname is a FIFO <span class="keyword">or</span> a block, <span class="built_in">set</span> the file to a nonblocking status.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The file descriptor</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately</span><br></pre></td></tr></table></figure><h2 id="creat"><a href="#creat" class="headerlink" title="creat"></a>creat</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//creats a file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - pathname: The file pathname</span><br><span class="line">    - mode:</span><br><span class="line">        - O_RDONLY: read only</span><br><span class="line">        - O_WRONLY: write only</span><br><span class="line">        - RDWR: write <span class="keyword">and</span> read</span><br><span class="line">        - O_APPEND: appends to file end</span><br><span class="line">        - O_CREATE: <span class="keyword">if</span> file <span class="keyword">not</span> exist, creates a <span class="keyword">new</span> one</span><br><span class="line">        - O_EXCL: Test wether a file exist <span class="keyword">or</span> <span class="keyword">not</span>, <span class="keyword">if</span> <span class="keyword">not</span> atomaicly creates a file</span><br><span class="line">        - O_TRUNC: I dont know</span><br><span class="line">        - O_NOCTTY: I dont know</span><br><span class="line">        - O_NONBLOCK: If ptahname is a FIFO <span class="keyword">or</span> a block, <span class="built_in">set</span> the file to a nonblocking status.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The file descriptor</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//close a file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fildes)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    - successed: <span class="number">0</span></span><br><span class="line">    - error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fildes,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor.</span><br><span class="line">    - offset: The offset.</span><br><span class="line">    - whence:</span><br><span class="line">        -SEEK_SET: The distance between file begin <span class="keyword">and</span> offset.</span><br><span class="line">        -SEEK_END: Set the offset to file end add offset.</span><br><span class="line">        -SEEK_CUR: Set the offset to current value add offset.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The <span class="keyword">new</span> location of file.</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">void</span>* buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor</span><br><span class="line">    - buff: The buffer to store data</span><br><span class="line">    - nbytes: Read how many bytes.</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed:</span><br><span class="line">        - meets EOF: <span class="number">0</span></span><br><span class="line">        - The bytes of read.</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets to appropriately.</span><br></pre></td></tr></table></figure><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fildes,<span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line">args:</span><br><span class="line">    - fildes: The file descriptor</span><br><span class="line">    - buff: The write buffer</span><br><span class="line">    - nbytes: How many bytes to write</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">    successed: The bytes of write</span><br><span class="line">    error: <span class="number">-1</span> <span class="keyword">and</span> errno sets appropriately</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package your own io functions</span></span><br><span class="line"><span class="comment">//io.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BEE_IO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BEE_IO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"utils.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"macro.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: opens a file, if not exist creats it.</span></span><br><span class="line"><span class="comment"> *@param[in] pathname: the file pathname</span></span><br><span class="line"><span class="comment"> *@param[in] ofalgs: The file open mode, default by creat and write and read.</span></span><br><span class="line"><span class="comment"> *@reurn: The file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname,<span class="keyword">int</span> oflags=<span class="number">0</span>,<span class="keyword">mode_t</span> mode=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: creats a file.</span></span><br><span class="line"><span class="comment"> *@param[in] pathname: the file pathname</span></span><br><span class="line"><span class="comment"> *@param[in] ofalgs: The file open mode, default by creat and write and read.</span></span><br><span class="line"><span class="comment"> *@return: The file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Creat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname, <span class="keyword">mode_t</span> mode=O_CREAT|O_RDWR)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: close a file.</span></span><br><span class="line"><span class="comment"> *@param[in] fd: the file descriptor</span></span><br><span class="line"><span class="comment"> *@return: NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence=SEEK_SET)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: read a file.</span></span><br><span class="line"><span class="comment"> *@param[in] fd: the file descriptor</span></span><br><span class="line"><span class="comment"> *@return: The file contains string..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@brief: write a file.</span></span><br><span class="line"><span class="comment"> *@param[in] fd: the file descriptor</span></span><br><span class="line"><span class="comment"> *@param[in] buffer: The string to write</span></span><br><span class="line"><span class="comment"> *@return: NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packages your own io functions</span></span><br><span class="line"><span class="comment">//io.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"io.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bee&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 8192</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname,<span class="keyword">int</span> oflags,<span class="keyword">mode_t</span> mode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(access(pathname.c_str(),F_OK)!=<span class="number">0</span>)&#123;</span><br><span class="line">        fd=open(pathname.c_str(),O_CREAT|O_RDWR|O_TRUNC,<span class="number">0777</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"creats a new file in: "</span>&lt;&lt;pathname&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oflags==<span class="number">0</span> &amp;&amp; mode==<span class="number">0</span>)&#123;</span><br><span class="line">        fd=open(pathname.c_str(),O_RDWR|O_APPEND);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fd=open(pathname.c_str(),oflags,mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"open file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Creat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pathname, <span class="keyword">mode_t</span> mode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd=creat(pathname.c_str(),mode);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"creat file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(close(fd)==<span class="number">-1</span>)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"close file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line">   lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">   <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        n=read(fd,buf,BUFF_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">            ASSERT_DESC(<span class="literal">false</span>,<span class="string">"read file error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">tmp</span><span class="params">(buf)</span></span>;</span><br><span class="line">        str.append(tmp);</span><br><span class="line">        bzero(buf,BUFF_SIZE);</span><br><span class="line">   &#125;</span><br><span class="line">   lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span></span>&#123;</span><br><span class="line">    <span class="comment">//char buf[]="";</span></span><br><span class="line">    <span class="keyword">int</span> len=buffer.size();</span><br><span class="line">    <span class="comment">//strncpy(buf,buffer.c_str(),len+1);</span></span><br><span class="line">    <span class="keyword">if</span>(write(fd,buffer.c_str(),len)!=len)&#123;</span><br><span class="line">        ASSERT_DESC(<span class="literal">false</span>,<span class="string">"write file error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;File-IO&quot;&gt;&lt;a href=&quot;#File-IO&quot; class=&quot;headerlink&quot; title=&quot;File IO&quot;&gt;&lt;/a&gt;File IO&lt;/h1&gt;&lt;h2 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
